---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---
# Memory

## Implemented Grid-Based Game World Search UI
**Date**: 2024-03-01
**Component**: GameWorldSearchTab, SearchResultsWidget, SearchPreviewWidget
**Issue**: Search functionality needed a more intuitive and visual interface for grid-based searching
**Changes Made**:
1. Created new GameWorldSearchTab with:
   - Direction-based movement controls
   - Grid size configuration
   - Template selection
   - Search progress visualization
   - Results management
2. Created SearchResultsWidget for:
   - List of found templates
   - Result details (confidence, position, etc.)
   - Screenshot preview integration
3. Created SearchPreviewWidget for:
   - Screenshot display with zoom controls
   - Match region highlighting
   - Smooth image scaling
4. Integrated direction-based movement:
   - Uses North/East definitions for grid navigation
   - Automatic inverse for South/West movements
   - Visual feedback during search
**Impact**:
- More intuitive search interface with visual grid
- Better control over search area and pattern
- Improved results management and preview
- Consistent movement using defined directions
**Testing**:
- Verified grid visualization updates
- Tested template selection and search
- Confirmed results display and preview
- Validated direction-based movement

## Implemented Direction-Based Movement and Calibration System
**Date**: 2024-03-01
**Component**: GameWorldDirection, DirectionWidget, SearchGridWidget
**Issue**: Search functionality needed a consistent way to move in cardinal directions and perform calibration
**Changes Made**:
1. Created GameWorldDirection class:
   - Manages North/East direction definitions (with South/West as inverses)
   - Handles direction testing with multiple runs
   - Performs calibration based on direction movements
   - Saves/loads direction definitions and calibration data
2. Created DirectionWidget for UI:
   - Direction definition interface (North/East)
   - Direction testing controls
   - Calibration controls with run count
   - Visual feedback for direction and calibration status
3. Created SearchGridWidget for visualization:
   - Grid pattern layout display
   - Current search position tracking
   - Search progress visualization
   - Already searched areas highlighting
4. Integrated direction-based calibration:
   - Uses North movement for Y-axis calibration
   - Uses East movement for X-axis calibration
   - Averages multiple runs for accuracy
   - Persists calibration data between sessions
**Impact**:
- More reliable movement in cardinal directions
- Consistent calibration process using defined movements
- Better visualization of search patterns and progress
- Improved user experience with clear feedback
**Testing**:
- Verified direction definition and persistence
- Tested direction movements with multiple runs
- Validated calibration calculations
- Confirmed search visualization accuracy

## Unified Template Matching Implementation
**Date**: 2024-03-01
**Component**: TemplateMatcher, Overlay, GameWorldSearch
**Issue**: Template matching was inconsistent between overlay and game world search, causing errors with unhashable numpy arrays
**Changes Made**:
1. Updated TemplateMatcher.find_matches method:
   - Added support for both template names list and screenshot input
   - Improved type hints with Union type
   - Fixed handling of numpy arrays
   - Added center property to TemplateMatch class
2. Updated Overlay._update_template_matching:
   - Now uses template names list instead of raw screenshot
   - Uses consistent template matching approach
   - Fixed match grouping logic
3. Unified template matching workflow:
   - Both overlay and game world search now use the same code path
   - Consistent handling of screenshots and templates
   - Same grouping and confidence handling
**Impact**:
- Template matching now works consistently in both overlay and search
- Fixed "unhashable type" error with numpy arrays
- More reliable template detection across all features
- Better code maintainability with unified implementation
**Testing**:
- Verified template matching works in overlay
- Confirmed game world search still functions correctly
- Tested template grouping and persistence
- Validated confidence thresholds

## Fixed Game World Search Template Matching
**Date**: 2024-03-01
**Component**: GameWorldSearch, TemplateMatcher
**Issue**: Search was failing due to template matching errors and SearchResult initialization issues
**Changes Made**:
1. Updated SearchResult class:
   - Added missing fields (positions_checked, search_time, success, screenshot_path)
   - Made game_position field optional
   - Fixed initialization parameters
2. Fixed template matching process:
   - Added proper screenshot handling
   - Ensured numpy array conversion
   - Improved error handling
3. Enhanced template matching workflow:
   - Added grayscale conversion
   - Fixed bounds calculation
   - Improved confidence threshold handling
**Impact**:
- Search functionality now works correctly
- Template matching is more reliable
- Better error handling and feedback
- Proper screenshot handling and saving
**Testing**:
- Verified template matching works
- Tested search with different templates
- Confirmed screenshot saving
- Validated error handling

## Fixed Game World Search Stop Functionality
**Date**: 2024-03-01
**Component**: GameWorldSearchTab
**Issue**: Search process could not be stopped using Escape/Q keys or stop button
**Changes Made**:
1. Added `stop_requested` flag to track stop requests
2. Implemented proper key event handling for Escape/Q keys
3. Rewritten search thread to:
   - Check stop flag at each position
   - Track progress properly
   - Update UI with current status
4. Fixed `_stop_search` method to use new flag
5. Added proper cleanup when search is stopped
**Impact**:
- Search can now be stopped immediately with Escape/Q keys
- Stop button works correctly
- Better feedback during search process
- Cleaner termination of search operations
**Testing**:
- Verified search stops with Escape key
- Confirmed search stops with Q key
- Tested stop button functionality
- Validated UI updates during search and stop

## Fixed Game World Search Implementation
**Date**: 2024-03-01
**Component**: GameWorldSearchTab
**Issue**: Search functionality was failing due to incorrect parameter passing and unclear documentation
**Changes Made**:
1. Fixed `_search_thread` method to correctly call `search_templates`
2. Removed unused `pattern_params` and `callback` parameters
3. Added proper parameter extraction for max_distance
4. Added comprehensive documentation of search functionality:
   - Detailed explanation of search patterns
   - Description of search settings
   - Step-by-step usage instructions
   - Preview functionality explanation
**Impact**:
- Search functionality now works correctly
- Users have clear guidance on how to use search features
- Better understanding of search pattern parameters
- Improved search reliability and usability
**Testing**:
- Verified search works with different patterns
- Tested template matching and preview
- Confirmed results display correctly
- Validated search settings functionality

## Fixed Calibration Data Display in GUI
**Date**: 2024-03-01
**Component**: CoordinateDisplayWidget
**Issue**: Calibration data was being loaded correctly but not displayed in the GUI
**Changes Made**:
1. Added new `_update_calibration_display()` method to update GUI with loaded calibration data
2. Method is called during widget initialization
3. Added display of:
   - Calibration status and color
   - X and Y axis ratios
   - Start and end point coordinates (screen and game)
   - Reset button enabled state
**Impact**:
- Calibration data is now visible immediately upon application start
- Users can see their saved calibration settings without needing to recalibrate
- Better feedback about the current calibration state
**Testing**:
- Verified calibration data loads and displays correctly on startup
- Confirmed all UI elements update properly with loaded data
- Tested with both calibrated and uncalibrated states

## 2024-03-01: Fixed Calibration Data Persistence

### Changes Made
1. Fixed calibration data saving and loading:
   - Updated paths to use correct relative paths from workspace root
   - Ensured config directory exists with proper permissions
   - Added proper error handling for file operations
   - Improved logging with file paths and calibration values
2. Enhanced data persistence:
   - Save calibration ratios and points to scout/config/calibration_data.json
   - Load calibration data on application startup
   - Maintain calibration between sessions
   - Handle missing or corrupt data gracefully
3. Improved logging and feedback:
   - Added detailed logging of save/load operations
   - Included file paths in log messages
   - Added comprehensive error messages
   - Enhanced debug information for calibration points

### Impact
1. Reliable calibration persistence:
   - Calibration settings now survive application restarts
   - Proper handling of file paths and permissions
   - Graceful fallback to defaults if needed
2. Better error handling:
   - Clear error messages for file operations
   - Proper handling of missing config directory
   - Graceful recovery from corrupt data
3. Enhanced debugging:
   - More detailed logging
   - Clear tracking of file operations
   - Better visibility into calibration state

### Testing
1. Verified data persistence:
   - Tested saving and loading calibration data
   - Confirmed data survives application restarts
   - Validated file paths and permissions
2. Tested error handling:
   - Verified behavior with missing config directory
   - Tested recovery from corrupt data
   - Confirmed proper default values
3. Validated logging:
   - Checked log messages for file operations
   - Verified calibration value logging
   - Confirmed error message clarity

## 2024-03-01: Enhanced Search Patterns for Game World Navigation

### Changes Made
1. Redesigned search patterns to account for game view characteristics:
   - Implemented 2:1 width-to-height ratio for view area
   - Added automatic calculation of view dimensions in game units
   - Created step sizes based on view dimensions with 80% overlap
   - Optimized pattern generation for efficient coverage
2. Improved search movement and coordination:
   - Added drag-based movement between search positions
   - Implemented proper OCR updates after each movement
   - Added position validation and error handling
   - Enhanced logging for movement tracking
3. Implemented three optimized search patterns:
   - Spiral: Outward spiral with view-based step sizes
   - Grid: Snake pattern with 80% view overlap
   - Expanding Circles: Radial search with dynamic point density

### Impact
1. More efficient searching:
   - Better coverage of game area with minimal overlap
   - Reduced unnecessary movements
   - More accurate position tracking
2. Improved reliability:
   - Proper handling of view area constraints
   - Better error recovery during search
   - More consistent coordinate updates
3. Enhanced user experience:
   - Faster template finding
   - More predictable search patterns
   - Better feedback during search

### Testing
1. Verified search patterns:
   - Tested all three patterns with different distances
   - Confirmed proper view overlap
   - Validated movement between positions
2. Tested coordinate handling:
   - Verified OCR updates after movements
   - Confirmed proper drag vector calculations
   - Tested error handling for failed movements
3. Validated search efficiency:
   - Measured coverage of search area
   - Tested template finding accuracy
   - Verified proper termination of searches

## 2024-03-01: Enhanced Calibration with Multiple Drags

### Changes Made
1. Added support for multiple calibration drags:
   - Added spinbox to UI for configuring number of drags (1-10)
   - Modified calibration process to perform multiple drags
   - Implemented averaging of calibration values across drags
   - Added progress feedback during calibration
2. Enhanced calibration accuracy:
   - Each drag provides an independent measurement
   - Results are averaged to reduce measurement error
   - Invalid measurements are skipped rather than failing
   - Detailed logging of individual measurements
3. Improved UI feedback:
   - Shows number of drags being performed
   - Displays progress during calibration
   - Shows how many measurements were averaged
   - Clear feedback on calibration results

### Impact
1. More accurate calibration:
   - Multiple measurements reduce random errors
   - Averaging provides more stable calibration values
   - Bad measurements are automatically filtered out
2. Better user control:
   - Users can choose accuracy vs. speed tradeoff
   - Default of 3 drags balances accuracy and time
   - Maximum of 10 drags for highest accuracy
3. Enhanced reliability:
   - Individual failed measurements don't fail calibration
   - More robust against OCR reading errors
   - Better handling of invalid measurements

### Testing
1. Verified multiple drag functionality:
   - Tested with different numbers of drags
   - Confirmed averaging works correctly
   - Validated error handling for failed measurements
2. Tested UI components:
   - Verified spinbox limits and default value
   - Confirmed progress feedback during calibration
   - Checked results display with measurement counts
3. Validated calibration accuracy:
   - Compared results with different drag counts
   - Verified consistency of measurements
   - Tested handling of invalid measurements

## 2024-03-01: Enhanced Calibration UI and Data Persistence

### Changes Made
1. Added detailed calibration results display to UI:
   - Added permanent display of calibration ratios
   - Enhanced success message with detailed results
   - Added visual feedback for calibration status
2. Improved calibration data persistence:
   - Added saving of start and end calibration points
   - Enhanced loading of calibration data
   - Added comprehensive logging of loaded calibration data
3. Updated UI to show current calibration values:
   - Added display of pixels per game unit for both axes
   - Added clear formatting and labels for results
   - Improved reset functionality to clear all displays

### Impact
1. Better user feedback:
   - Users can now see calibration results at all times
   - Clear visual indication of calibration status
   - Detailed feedback on calibration success/failure
2. Improved persistence:
   - Calibration points are now saved between sessions
   - More robust loading of calibration data
   - Better error handling for missing or corrupt data
3. Enhanced user experience:
   - More informative UI
   - Clearer feedback on calibration process
   - Better persistence of calibration settings

### Testing
1. Verified calibration results display:
   - Confirmed results are shown after successful calibration
   - Tested display formatting and clarity
   - Verified reset functionality
2. Tested data persistence:
   - Confirmed calibration data is saved correctly
   - Verified loading of saved calibration points
   - Tested error handling for invalid data
3. Validated UI updates:
   - Checked all labels and displays
   - Confirmed proper status updates
   - Verified reset functionality

## 2024-03-01: Fixed Wait Method in Calibration Process

### Changes Made
- Fixed incorrect wait method call in `GameWorldCoordinator`
- Changed `game_actions.wait()` to `time.sleep()` to use the correct waiting mechanism
- Ensured consistent timing between drag operations and OCR readings

### Impact
1. Fixed calibration error where drag operation was failing due to incorrect wait method
2. Ensured proper timing between drag and coordinate readings
3. Improved reliability of the calibration process

### Testing
1. Verified that drag operations work correctly during calibration
2. Confirmed proper timing between operations
3. Tested complete calibration process with drag and coordinate readings

## 2024-03-01: Fixed GameWorldCoordinator Mouse Movement Method

### Changes Made
- Fixed method name mismatch between `GameWorldCoordinator` and `GameActions`
- Changed `move_mouse` to `move_mouse_to` to match the actual method name in `GameActions`
- Fixed sleep call to use `time.sleep` instead of non-existent `wait` method

### Impact
1. Fixed calibration error where mouse movement was failing due to incorrect method name
2. Ensured proper mouse movement during calibration process
3. Fixed sleep/wait functionality during calibration

### Testing
1. Verified that mouse movement works during calibration
2. Confirmed that calibration process can complete successfully
3. Tested proper timing between mouse movements

## 2024-03-01: Fixed GameWorldCoordinator Initialization with GameActions

### Changes Made
- Fixed initialization of `GameWorldCoordinator` in `GameWorldSearchTab` to properly pass the `game_actions` parameter
- This ensures that the coordinator has access to mouse movement functionality needed for calibration

### Impact
1. Fixed calibration error where mouse movement was failing due to missing game_actions
2. Enabled proper calibration point marking and drag operations
3. Improved reliability of the calibration process

### Testing
1. Verified that calibration points can now be marked without errors
2. Confirmed that mouse movement works during calibration
3. Tested complete calibration process with drag operations

## 2023-08-04: Fixed Calibration Point Initialization

### Changes Made
- Fixed issue where calibration points weren't being set because calibration wasn't started
- Modified `_start_marking_point` method in `CoordinateDisplayWidget` to start calibration when marking the first point
- Ensured calibration state is properly initialized before point marking

### Impact
1. Fixed issue where calibration points couldn't be set
2. Improved user experience by automatically starting calibration
3. Prevented confusing error messages about calibration not being in progress
4. Maintained proper calibration state throughout the process

### Testing
1. Verified that calibration points can be set successfully
2. Confirmed that calibration process works end-to-end
3. Tested error handling for invalid points
4. Validated calibration state management

## 2023-08-04: Improved Calibration UI with Separate Point Selection

### Changes Made
1. Redesigned the calibration UI in `CoordinateDisplayWidget`:
   - Added separate buttons for selecting start and end points
   - Added coordinate display for both start and end points
   - Added a "Reset" button to clear calibration points
   - Improved button state management based on calibration progress
2. Enhanced the calibration workflow:
   - Clear separation between point selection and calibration start
   - Better visual feedback with point coordinates display
   - More intuitive button labeling and organization
   - Improved status messages during calibration process

### Impact
1. More intuitive calibration process:
   - Clear distinction between start and end point selection
   - Visual feedback showing selected point coordinates
   - Better guidance through the calibration steps
2. Improved user experience:
   - Separate buttons prevent confusion about which point is being marked
   - Reset option allows starting over without canceling
   - Clear status messages guide the user through the process
3. Better error prevention:
   - Button states prevent invalid operations
   - Clear visual feedback helps users understand the current state
   - Reset option helps recover from mistakes

### Testing
1. Tested point selection workflow:
   - Verified start point selection and coordinate display
   - Confirmed end point selection and coordinate display
   - Validated button state changes during selection
2. Tested calibration process:
   - Confirmed calibration starts only with both points selected
   - Verified reset functionality clears all points
   - Tested error handling and feedback
3. Validated UI feedback:
   - Checked coordinate display accuracy
   - Confirmed status message clarity
   - Verified button state logic

## 2023-08-04: Fixed CoordinateDisplayWidget Initialization

### Changes Made
- Fixed initialization of `CoordinateDisplayWidget` in `GameWorldSearchTab` to properly pass the `window_manager` parameter
- Updated `_create_ui` method to include `window_manager` in widget initialization
- Ensured proper parameter passing for position marking functionality

### Impact
1. Fixed application crash when initializing the Game World Search tab
2. Restored proper functionality of coordinate display and calibration
3. Enabled position marking for calibration points
4. Maintained consistent window management across the application

### Testing
1. Verified that the Game World Search tab initializes correctly
2. Confirmed that coordinate display works properly
3. Tested position marking functionality
4. Validated calibration process with position marking

## July 27, 2023 - Calibration System Enhancement

### Changes Made
1. Implemented new point-based calibration system with automated drag:
   - Added `CalibrationPoint` class to store screen and game coordinates
   - Modified `GameWorldCoordinator` to use two fixed points for calibration
   - Added automated drag operation between points for consistent measurements
   - Integrated `PositionMarker` overlay for visual point selection
   - Updated `CoordinateDisplayWidget` with new UI and workflow

### Impact
1. Improved calibration accuracy:
   - Uses consistent drag operation instead of manual dragging
   - Eliminates issues with mouse centering
   - Provides visual feedback for point selection
2. Enhanced user experience:
   - Clear visual overlay for marking points
   - Step-by-step instructions
   - Better error handling and validation
3. More reliable coordinate conversion:
   - Consistent measurement process
   - Better handling of game world coordinate changes
   - Improved validation of calibration results

### Testing
1. Tested point marking system:
   - Verified overlay appears and captures points correctly
   - Confirmed ESC key cancels marking operation
   - Validated point coordinates are stored accurately
2. Tested calibration process:
   - Verified automated drag operation works correctly
   - Confirmed OCR readings at both points
   - Validated calibration calculations
3. Tested coordinate conversion:
   - Verified screen-to-game and game-to-screen conversions
   - Confirmed drag vector calculations
   - Validated position tracking accuracy

## 2023-07-27: Unified OCR Region Handling

### Changes Made
- Removed the separate coordinate region selection system from `GameWorldCoordinator`
- Modified `GameWorldCoordinator.update_current_position_from_ocr()` to always use the OCR region from `TextOCR`
- Removed the `set_coord_region()` method from `GameWorldCoordinator`
- Updated `CoordinateDisplayWidget` to remove the coordinate region dropdown
- Added an informational label explaining that coordinates are read from the OCR region selected in the Overlay tab
- Enhanced error messaging when no OCR region is set
- Updated the TB_Scout_Application_Report.md to document these changes

### Impact
- Simplified the user experience by using a single OCR region for all coordinate reading operations
- Reduced code complexity by eliminating redundant region handling
- Improved error messaging to guide users when OCR region is not set
- Enhanced consistency in coordinate reading across all application features
- Eliminated potential confusion from having multiple region selection mechanisms
- Streamlined the calibration process by using the same OCR region

### Testing
- Verified that coordinate reading works correctly using the OCR region from the overlay tab
- Confirmed that calibration process uses the OCR region from the overlay tab
- Tested error handling when no OCR region is set
- Verified that the UI provides clear guidance on using the OCR region from the overlay tab
- Confirmed that the application report is updated with the new information

## 2023-07-26: Implemented Drag Distance Calibration System

### Changes Made
- Completely redesigned the calibration system to use a drag distance approach instead of fixed calibration points
- Removed the old calibration point system that relied on fixed screen positions
- Added new methods to `GameWorldCoordinator`:
  - `start_calibration()`: Captures the first position for calibration
  - `complete_calibration()`: Captures the second position and calculates the pixel-to-game-unit ratio
  - `cancel_calibration()`: Cancels the current calibration process
  - `get_calibration_status()`: Returns the current calibration status
  - `_calibrate()`: Internal method to calculate the pixel-to-game-unit ratio
- Updated `CoordinateDisplayWidget` with a new UI for the drag distance calibration:
  - Added "Start Calibration", "Complete Calibration", and "Cancel" buttons
  - Added calibration status display
  - Added instructions for the calibration process
  - Removed old calibration point management UI
- Improved the coordinate conversion accuracy by using the actual distance traveled in both screen pixels and game world units
- Added comprehensive error handling and validation throughout the calibration process
- Updated documentation to reflect the new calibration approach

### Impact
- Significantly improved accuracy of coordinate conversion between screen and game world
- More intuitive calibration process that accounts for the game's scrolling nature
- Better handling of different zoom levels and screen resolutions
- More reliable navigation and search operations due to improved coordinate conversion
- Simplified UI with clear instructions for the calibration process
- Enhanced user experience with immediate visual feedback during calibration
- Eliminated the need for multiple fixed calibration points

### Testing
- Verified that the calibration process correctly captures start and end positions
- Confirmed that the pixel-to-game-unit ratio is calculated accurately
- Tested calibration with different drag distances to ensure consistent results
- Verified that coordinate conversion is accurate after calibration
- Confirmed that the UI provides clear feedback throughout the calibration process
- Tested error handling by attempting calibration with invalid positions
- Verified that canceling calibration properly resets the calibration state

## 2023-07-24: Fixed OCR Button Text Update Delay

### Changes Made
- Refactored the `_toggle_ocr` method in `OverlayController` to use asynchronous operations
- Created a centralized `_update_ocr_button_state` method for managing OCR button appearance
- Added a new `_perform_ocr_toggle` method that runs asynchronously after button state updates
- Updated the `keyPressEvent` method to use the centralized button state management
- Added a `update_ocr_button_from_state` method to synchronize button state with OCR state
- Improved error handling throughout the OCR toggle process

### Impact
- OCR button text and style now update immediately when clicked
- UI remains responsive during OCR operations
- Consistent button state management across the application
- Better user experience with immediate visual feedback
- More reliable error handling and recovery
- Improved code organization with clear separation of concerns

### Testing
- Verified that the OCR button text updates immediately when clicked
- Confirmed that the UI remains responsive during OCR operations
- Tested error handling by simulating exceptions during OCR toggle
- Verified that the button state correctly reflects the OCR state
- Confirmed that keyboard shortcuts properly update the button state

## 2023-07-23: Fixed OCR Button State Inconsistency

### Changes Made
- Standardized the OCR button styling to use consistent colors (green for ON, red for OFF)
- Updated the `keyPressEvent` method to properly set the button text and style when stopping OCR
- Enhanced the `_toggle_ocr` method to ensure consistent button state management
- Updated the AutomationTab's OCR button styling to match the main OCR button
- Improved error handling to ensure the button always reflects the correct state
- Added more detailed logging to track OCR state changes

### Impact
- OCR toggle button now has only two states (ON/OFF) with consistent styling
- Button state is now properly synchronized with the actual OCR state
- Consistent behavior when toggling OCR via different methods (UI button vs. keyboard shortcuts)
- Improved user experience with clear visual feedback on OCR state
- More reliable error handling ensures the UI always reflects the actual state
- Better debugging capabilities with enhanced logging

### Testing
- Verified that the OCR button has only two states (green for ON, red for OFF)
- Confirmed that pressing Escape/Q key properly updates the OCR button style
- Tested toggling OCR via the UI button and verified consistent styling
- Verified that error handling properly updates the button state
- Confirmed that the AutomationTab's OCR button has consistent styling

## 2023-07-22: Fixed Escape/Q Key to Only Deactivate Processes

### Changes Made
- Modified the `keyPressEvent` method in the `OverlayController` class to call stop methods directly instead of toggle methods
- For OCR, now calling `_stop_ocr()` directly instead of `_toggle_ocr()`
- For template matching, now calling `overlay.stop_template_matching()` directly and updating settings
- Added a flag to track whether any processes were actually stopped
- Updated the status message to indicate when no active processes were found to stop
- Ensured all UI elements are properly updated to reflect the stopped state

### Impact
- Escape and Q keys now only deactivate processes, never activate them
- Consistent behavior with user expectations for stop keys
- More intuitive user experience with keyboard shortcuts
- Clear feedback when no active processes are found to stop
- Improved reliability of process management
- Consistent behavior across different stopping mechanisms

### Testing
- Verified that pressing Escape key only turns off template matching and never turns it on
- Confirmed that pressing Q key only turns off OCR processes and never turns them on
- Tested behavior when no processes are active to ensure appropriate feedback
- Verified that UI elements correctly reflect the stopped state
- Confirmed that the status bar provides appropriate feedback based on whether processes were stopped

## 2023-07-21: Fixed Escape/Q Key Process Toggling

### Changes Made
- Updated the `keyPressEvent` method in the `OverlayController` class to properly update button states before calling toggle methods
- Enhanced the `_toggle_pattern_matching` method to ensure button text and color are updated when toggled off
- Improved the `_toggle_ocr` method with better error handling and state management
- Added checks to ensure button states are consistent with the actual process states
- Ensured all toggle methods properly handle errors and set processes to OFF state in case of exceptions

### Impact
- Escape and Q keys now properly toggle off template matching, OCR, and automation processes
- Button states are now correctly updated when processes are stopped via keyboard shortcuts
- Consistent behavior between UI button clicks and keyboard shortcuts for stopping processes
- More robust error handling in toggle methods prevents processes from being left in an inconsistent state
- Improved user experience with reliable keyboard shortcuts for stopping processes

### Testing
- Verified that pressing Escape key properly toggles off template matching with correct button state updates
- Confirmed that pressing Q key properly toggles off OCR processes with correct button state updates
- Tested stopping automation sequences with keyboard shortcuts and verified button state updates
- Verified error handling by simulating exceptions during toggle operations
- Confirmed that the status bar correctly updates when processes are stopped via keyboard shortcuts

## 2023-07-20: Fixed Stop Key Error in OCR Process

### Changes Made
- Fixed the `keyPressEvent` method in the `OverlayController` class to call the correct methods when stopping processes with keyboard shortcuts
- Changed `_handle_ocr_toggle()` to `_toggle_ocr()` for stopping OCR processes
- Changed `_handle_pattern_toggle()` to `_toggle_pattern_matching()` for stopping template matching
- Fixed attribute name check from `self.overlay.is_active` to `self.overlay.active`
- Added a new `is_sequence_running()` method to the `AutomationTab` class to check if a sequence is currently running
- Updated the `keyPressEvent` method to safely check for the existence of the method before calling it
- Ensured proper error handling in the key event processing

### Impact
- Fixed application crash when pressing Escape or Q keys to stop OCR processes
- Fixed application crash when checking overlay status during stop key processing
- Fixed application crash when checking if a sequence is running in the automation tab
- Improved reliability of keyboard shortcuts for stopping active processes
- Enhanced user experience by ensuring stop keys work consistently
- Maintained consistent behavior across different stopping mechanisms (UI buttons vs. keyboard shortcuts)

### Testing
- Verified that pressing Escape key properly stops OCR processes without errors
- Confirmed that pressing Q key properly stops template matching without errors
- Tested stopping automation sequences with keyboard shortcuts
- Tested stopping multiple active processes simultaneously with keyboard shortcuts
- Verified that the status bar correctly updates when processes are stopped via keyboard shortcuts

## 2023-07-19: OCR Mouse Centering from Overlay Tab

### Changes Made
- Updated the `_start_ocr` method in the `OverlayController` class to center the mouse before starting OCR
- Added a call to the `game_coordinator.update_current_position_from_ocr()` method from the game world search tab
- Ensured proper error handling if the game world search tab is not available
- Added comprehensive logging to track the mouse centering process
- Improved the method documentation to clearly explain the steps taken during OCR activation

### Impact
- Consistent mouse centering regardless of which tab is used to activate OCR
- Improved OCR accuracy due to consistent mouse positioning
- More reliable coordinate extraction across all application components
- Enhanced debugging capabilities with detailed logging of OCR activation
- Better user experience with more consistent OCR results

### Testing
- Verified that the mouse is properly centered when activating OCR from the overlay tab
- Confirmed that OCR results are consistent regardless of which tab is used to start OCR
- Tested error handling when the game world search tab is not available
- Verified that logging correctly tracks the mouse centering process

## 2023-07-18: Enhanced Mouse Centering for OCR

### Changes Made
- Completely redesigned the `_center_mouse_for_measurement` method in `GameWorldCoordinator` to use multiple mouse movement approaches:
  1. win32api.SetCursorPos
  2. ctypes.windll.user32.SetCursorPos
  3. pyautogui.moveTo
  4. ctypes.windll.user32.mouse_event (as a final fallback)
- Added verification after each mouse movement attempt to ensure the mouse actually moved to the target position
- Added the `_ensure_window_active` method to activate the game window before centering the mouse
- Updated the coordinate region calculation to account for window frame offsets
- Improved the client area detection to center the mouse in the actual game area, not just the window frame
- Added comprehensive logging to track mouse movement attempts and results
- Updated the `update_current_position_from_ocr` method to ensure the window is active before trying to center the mouse

### Impact
- More reliable mouse centering before taking OCR screenshots
- Improved accuracy of coordinate extraction due to consistent mouse positioning
- Better handling of window frame offsets for more precise region selection
- Enhanced debugging capabilities with detailed logging of mouse movement attempts
- More robust error handling and recovery when mouse movement fails
- Improved user experience with more reliable OCR functionality

### Testing
- Verified that the mouse properly centers in the game window before taking OCR screenshots
- Confirmed that the window is properly activated before mouse operations
- Tested all mouse movement methods to ensure they work correctly
- Verified that the coordinate region calculation correctly accounts for window frame offsets
- Confirmed that OCR screenshots capture the correct region due to proper mouse positioning

## 2023-07-17: Persistent Game World Coordinates

### Changes Made
- Modified `GameState` class to maintain the last valid coordinates and never reset them unless explicitly told to do so
- Added `_is_valid_coordinate` method to validate coordinates before updating them
- Updated `update_coordinates` method to return a boolean indicating whether any coordinates were updated
- Added `reset_coordinates` method to explicitly reset coordinates when needed
- Updated `TextOCR` class to always emit the latest coordinates, even if OCR fails
- Enhanced `GameWorldCoordinator` to use the last valid coordinates when OCR fails
- Updated `GameWorldSearch` to use the last valid coordinates from the game state when checking for templates
- Added comprehensive logging to track coordinate updates and usage

### Impact
- Game world coordinates are now maintained consistently across the application
- OCR failures no longer cause coordinates to be lost or reset
- Template matching now uses the last valid coordinates when OCR fails
- All components now share coordinate information effectively
- Invalid coordinates are now properly validated and rejected
- Improved reliability of coordinate-dependent operations
- Enhanced debugging capabilities with detailed logging

### Testing
- Verified that coordinates are maintained when OCR fails
- Confirmed that template matching uses the last valid coordinates
- Tested coordinate validation to ensure only valid values are stored
- Verified that coordinates are shared effectively between components
- Confirmed that coordinates are never reset unless explicitly requested

## 2023-07-16: Continuous OCR Updates and Automatic Search Starting Point

### Changes Made
- Removed manual "Update Position" button from search controls
- Removed "Update Now" and "Auto Update" buttons from coordinate display
- Modified `CoordinateDisplayWidget` to always update automatically
- Updated `GameWorldSearch.search_templates()` to always use current position from OCR as starting point
- Enhanced `update_current_position_from_ocr()` with additional logging and verification
- Improved error handling in the OCR update process

### Impact
- Simplified user interface by removing unnecessary manual controls
- Ensured consistent coordinate updates across the application
- Eliminated potential for outdated coordinates by maintaining a single source of truth
- Improved reliability of search operations by always using current position
- Enhanced debugging capabilities with more detailed logging
- Reduced user confusion by removing toggles and manual update buttons

### Testing
- Verified that coordinates update automatically without manual intervention
- Confirmed that search patterns always use the current position as starting point
- Tested mouse centering reliability with enhanced logging
- Validated that all components reflect the latest coordinates from OCR

## 2023-07-15: Mouse Centering and Search Button Fixes

### Changes Made
- Enhanced the `_center_mouse_for_measurement` method in `GameWorldCoordinator` to use `win32api` for more reliable mouse movement, with `pyautogui` as a fallback
- Added a "Update Position" button to the search controls widget to explicitly trigger position updates
- Improved the `update_current_position` method to provide visual feedback with success/failure messages
- Added wait cursor during position updates to indicate processing
- Enhanced logging throughout the position update process

### Impact
- More reliable mouse centering before taking OCR screenshots
- Better user experience with explicit controls for position updates
- Improved feedback during position updates
- More robust error handling and recovery
- Better debugging capabilities with enhanced logging

### Testing
- Verified that the mouse is properly centered before taking OCR screenshots
- Confirmed that the "Update Position" button correctly updates the current position
- Tested error handling and feedback for various scenarios
- Checked that the search buttons function correctly

## 2023-07-14: Strict Coordinate Format Enforcement

### Changes Made
- Modified the coordinate extraction to strictly enforce the expected format of `K: 000 X: 000 Y: 000`
- Updated the text scoring system to heavily prioritize text matching the expected format
- Added a more specific OCR configuration to improve recognition of the expected format
- Simplified text cleaning to focus only on essential character replacements
- Added clear validation of coordinate values to ensure they are within valid ranges
- Improved logging to clearly indicate when text doesn't match the expected format

### Impact
- More reliable coordinate extraction by rejecting invalid formats
- Reduced false positives in coordinate recognition
- Clearer error messages when coordinates can't be extracted
- Improved consistency in coordinate extraction
- Better debugging capabilities with enhanced logging of rejected formats

### Testing
- Verified that only text matching the expected format is accepted
- Confirmed that invalid coordinate formats are properly rejected
- Tested that the scoring system correctly prioritizes the expected format
- Checked that coordinate values are properly validated

## OCR System and Game World Search Integration Fixes (2023-07-10)

### Changes Made
- Fixed the OCR system integration with the game world search functionality
- Ensured consistent screenshot capture and saving for debugging purposes
- Modified `GameWorldCoordinator.update_current_position_from_ocr()` to properly utilize the TextOCR system
- Enhanced the `GameWorldSearch._check_for_templates()` method to always save screenshots for debugging
- Improved the `CoordinateDisplayWidget._update_coordinates()` method to handle different coordinate sources
- Added additional logging for better debugging of coordinate updates
- Ensured the game world search tab properly updates when coordinates change

### Impact
- The OCR system now consistently extracts and displays coordinates from the game UI
- Debug screenshots are saved with consistent naming for easier comparison
- The game world search functionality now reliably updates coordinates during searches
- Coordinate display is more robust and handles edge cases better

### Testing
- Verified that coordinates are properly extracted and displayed in the game world search tab
- Confirmed that screenshots are saved during template searches regardless of settings
- Tested that the coordinate display widget updates correctly when coordinates change 

## 2023-07-25: Added Detailed Calibration Point Documentation

### Changes Made
- Created a comprehensive documentation file `documentation/calibration_point_explanation.md` explaining the "Add Calibration Point" feature
- Updated the TB Scout Application Report with detailed information about the coordinate calibration system
- Added calibration-related methods to the GameWorldCoordinator class description in the report
- Added the CoordinateDisplayWidget class to the Supporting Classes section in the report
- Enhanced the Game World Coordination feature description with calibration details

### Impact
- Improved understanding of the coordinate calibration system for developers and users
- Clearer documentation of how the calibration points improve coordinate conversion accuracy
- Better explanation of the relationship between screen coordinates and game world coordinates
- More comprehensive documentation of the TB Scout application's features and components
- Enhanced onboarding for new developers working on the coordinate system

### Documentation Details
- Explained the purpose and function of the calibration point system
- Detailed the technical implementation of the calibration algorithm
- Provided guidance on optimal usage of the calibration feature
- Outlined the benefits and importance of proper calibration
- Documented limitations and considerations when using the calibration system 

## 2023-07-26: Added Calibration Point Management and Persistence

### Changes Made
- Added `remove_calibration_point` method to `GameWorldCoordinator` to remove calibration points by index
- Added `clear_calibration_points` method to `GameWorldCoordinator` to clear all calibration points
- Added `get_calibration_point` method to `GameWorldCoordinator` to get a calibration point by index
- Implemented `_save_calibration_points` and `_load_calibration_points` methods for persistence
- Updated `_initialize` method to load calibration points on startup
- Enhanced `CoordinateDisplayWidget` with UI elements for managing calibration points:
  - Added a combo box to display and select calibration points
  - Added a "Remove" button to remove the selected calibration point
  - Added a "Clear All" button to clear all calibration points
  - Added `_remove_calibration_point` and `_clear_calibration_points` methods
  - Added `_update_calibration_points_list` method to update the UI
- Updated the TB Scout Application Report with the new calibration point management features

### Impact
- Calibration points now persist between application sessions, improving user experience
- Users can now manage calibration points through the UI, removing individual points or clearing all points
- Improved error handling and feedback for calibration point management
- Better visualization of calibration points in the UI
- More robust coordinate conversion with persistent calibration
- Enhanced documentation of calibration point features

### Testing
- Verified that calibration points are saved to disk and loaded on startup
- Confirmed that the UI correctly displays calibration points and enables/disables buttons
- Tested removing individual calibration points and clearing all points
- Verified that calibration is recalculated correctly after removing points
- Confirmed that the status label correctly reflects the number of calibration points
- Tested error handling for invalid calibration point indices

## 2023-07-27: Fixed Calibration Point Mouse Position Issue

### Changes Made
- Updated the `_add_calibration_point` method in `CoordinateDisplayWidget` to properly use the existing OCR solution
- Replaced the custom coordinate update with a direct call to `game_coordinator.update_current_position_from_ocr()`
- Added validation to ensure the position data is valid before adding a calibration point
- Improved error handling and logging for the calibration point addition process
- Added clear comments explaining that the center of the window is the correct screen position because the OCR method centers the mouse

### Impact
- Calibration points now correctly use the same position where the OCR reading was taken
- More accurate mapping between screen coordinates and game world coordinates
- Improved reliability of the coordinate conversion system
- Better error handling prevents adding invalid calibration points
- Enhanced logging provides better debugging information
- More consistent behavior with the rest of the application

### Testing
- Verified that the mouse is properly centered before taking OCR readings for calibration points
- Confirmed that calibration points use the correct screen position (center of window)
- Tested error handling by attempting to add calibration points with invalid coordinates
- Verified that the calibration system correctly converts between screen and game coordinates
- Confirmed that navigation and template matching are more accurate with the fixed calibration

## 2023-07-27: Implemented OCR Max Frequency Limit

### Changes Made
- Added a `max_frequency` setting to the OCR configuration with a default value of 2.0 updates per second
- Modified the `ConfigManager` class to handle the new `max_frequency` setting:
  - Added `max_frequency` to `DEFAULT_OCR_SETTINGS` with a value of 2.0
  - Updated `get_ocr_settings()` to retrieve the `max_frequency` setting
  - Updated `update_ocr_settings()` to save the `max_frequency` setting
- Enhanced the `TextOCR` class to respect the maximum frequency limit:
  - Added loading of `max_frequency` from config in the constructor
  - Modified `set_frequency()` to ensure the frequency doesn't exceed `max_frequency`
  - Added `get_max_frequency()` method to retrieve the current maximum allowed frequency
  - Updated logging to include maximum frequency information
- Updated the GUI controller to use the maximum frequency in the OCR controls:
  - Modified the frequency slider and spinbox to use the `max_frequency` from config
  - Updated the range label to show the dynamic maximum frequency
  - Ensured the slider and spinbox values don't exceed the maximum frequency

### Impact
- Prevents excessive OCR updates that could cause performance issues or crashes
- Provides a configurable limit that can be adjusted based on system capabilities
- Improves application stability by preventing too frequent OCR operations
- Enhances user experience by providing clear feedback on frequency limits
- Maintains consistent behavior across different parts of the application

### Testing
- Verified that the OCR frequency controls respect the maximum frequency
- Confirmed that the frequency slider and spinbox are properly limited
- Tested that the range label correctly shows the maximum frequency
- Verified that the TextOCR class properly enforces the maximum frequency
- Confirmed that the configuration is properly saved and loaded

## Current Task: OCR Process Performance Improvements

### Changes Made
- Optimized the OCR process in `TextOCR.extract_text()` to reduce temporary files:
  - Only process the preferred OCR method when not in auto mode
  - Standardized configuration parameters to reduce redundancy
  - Simplified the OCR method selection process
- Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
  - Implemented a minimum 500ms delay between OCR operations
  - Added early return with existing coordinates when rate limited
  - Improved logging to track rate-limited operations
- Enhanced error handling throughout the OCR process:
  - Better timeout handling to prevent the application from hanging
  - Improved fallback to existing coordinates when OCR fails
  - More robust state tracking for the OCR process

### Impact
- Significantly reduced the number of temporary PNG files created in the system temp folder
- Improved application responsiveness during OCR operations
- Prevented the application from hanging or becoming unresponsive
- Ensured coordinates are displayed in the GUI even when OCR partially fails
- Fixed issues with the Q/Escape keys not properly stopping the OCR process
- Made the OCR process more compatible with the drag calibration system

### Testing
- Verified that the application remains responsive during OCR operations
- Confirmed that fewer temporary files are created during OCR
- Tested that the Q/Escape keys properly stop the OCR process
- Verified that coordinates are displayed in the GUI even when some values are missing
- Confirmed that the OCR process works correctly with the drag calibration system

## Current Task
Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Context
The TB Scout application was experiencing an issue where the OCR process would get stuck and the application would become unresponsive when trying to stop the OCR process using the Escape or Q keys.

### Root Cause
1. The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
2. The `pytesseract` library operations could not be interrupted once started
3. The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
4. Timeout mechanisms were not properly integrated with cancellation flags

### Changes Made
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Benefits
1. The application now properly responds to Escape/Q keys during OCR operations
2. The OCR process stops immediately when cancellation is requested
3. The UI remains responsive during OCR operations
4. Proper error messages are displayed when OCR is cancelled
5. Auto-update is properly stopped when OCR is cancelled

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

### Date
Last updated: 2023-08-03

## Current Task
Fixed Excessive OCR Updates and Mouse Centering

### Context
The TB Scout application was still experiencing issues with the OCR process:
1. OCR was updating too frequently, causing constant mouse centering
2. The mouse was constantly being reset to the center of the game window
3. The OCR process was still not responding properly to Escape/Q keys
4. Auto-update in the coordinate widget was causing excessive OCR operations

### Root Cause
1. Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
2. Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
3. Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
4. Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
5. Timeout checks weren't frequent enough to detect cancellation requests quickly

### Changes Made
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Benefits
1. OCR updates now occur at a reasonable frequency
2. The mouse is no longer constantly being centered
3. Escape/Q keys properly stop all OCR-related processes
4. Auto-update is properly disabled when OCR is stopped
5. The application remains responsive during OCR operations

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

### Date
Last updated: 2023-08-04 

## March 1, 2024 - Calibration System Improvements

### Calibration Display Consistency
Fixed inconsistency in calibration result display across different parts of the UI:
1. DirectionWidget and CoordinateDisplayWidget now use the same calculation methods
2. All displays show consistent values for:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Pixels per game unit ratios
3. Added validation against window dimensions
4. Enhanced logging for better debugging

### Current Status
1. Calibration System:
   - Fully functional with consistent display
   - Proper wrapping of coordinates (0-999 range)
   - Accurate ratio calculations
   - Detailed movement information in logs and UI
2. GUI Components:
   - DirectionWidget shows complete calibration details
   - CoordinateDisplayWidget matches log output
   - Both widgets validate screen distances
3. Validation:
   - Screen distances checked against window size
   - Game unit movements properly wrapped
   - Ratios calculated consistently

### Next Steps
1. Consider adding:
   - Visual representation of calibration movements
   - Calibration history tracking
   - Automatic validation of calibration accuracy
2. Potential improvements:
   - Save calibration profiles for different zoom levels
   - Add calibration verification tools
   - Implement automatic recalibration detection

## Recent Changes
- Added "Use All Templates" checkbox to GameWorldSearchTab
  - Default state is checked
  - Automatically selects all available templates when checked
  - Clears template selection when unchecked
  - Integrated with template loading to maintain selection state
  - Located in search settings section above template list

## Direction Calibration System Status
**Last Updated:** March 1, 2024

### Recent Improvements
1. Fixed inconsistent Y measurements during calibration
   - Added proper stabilization delays
   - Implemented multiple OCR updates at critical points
   - Increased wait times after movements
   - Result: Consistent measurements across all calibration runs

### Current Status
- Calibration system is now stable and reliable
- OCR integration is working correctly
- Movement measurements are consistent
- Proper game world stabilization is implemented

### Technical Details
- Initial stabilization: 1.5s wait + 3x OCR updates
- Post-movement stabilization: 2.0s wait + 3x OCR updates
- OCR update interval: 0.5s between updates
- Movement validation is working correctly
- Position tracking is accurate

### Next Steps
1. Monitor calibration performance in different game states
2. Consider adding calibration quality metrics
3. Look into potential performance optimizations

[Rest of the document remains unchanged...] 