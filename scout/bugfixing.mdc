---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---
# Bug Fixing Log

## 2023-07-27: Fixed Coordinate Region Mismatch Issue

### Issues Fixed
- Error message "make sure coordinates are visible and can be read" during calibration due to coordinate region mismatch
- Confusion caused by having two separate region selection mechanisms (OCR region in overlay tab and coordinate region in game world coordinates widget)
- Inconsistent coordinate reading between calibration and normal operation
- Potential for OCR to fail if the wrong coordinate region was selected

### Root Cause Analysis
- The application had two separate region selection mechanisms:
  1. OCR region selection in the overlay tab for general text extraction
  2. Coordinate region selection in the game world coordinates widget specifically for reading game coordinates
- This dual system caused confusion and inconsistency, as users might select an OCR region in the overlay tab but have a different coordinate region selected in the game world coordinates widget
- During calibration, the application was using the coordinate region instead of the OCR region, leading to failures if the coordinate region didn't contain visible coordinates

### Solutions Implemented
- Removed the separate coordinate region selection system from `GameWorldCoordinator`
- Modified `GameWorldCoordinator.update_current_position_from_ocr()` to always use the OCR region from `TextOCR`
- Removed the `set_coord_region()` method from `GameWorldCoordinator`
- Updated `CoordinateDisplayWidget` to remove the coordinate region dropdown
- Added an informational label explaining that coordinates are read from the OCR region selected in the Overlay tab
- Enhanced error messaging when no OCR region is set
- Updated documentation to reflect these changes

## 2023-07-24: Fixed OCR Button Text Update Delay

### Issues Fixed
- OCR button text in the overlay tab had a significant delay when toggling between ON/OFF states
- Button state updates were blocked by time-consuming OCR operations
- Inconsistent button state management across different parts of the application

### Root Cause Analysis
- The `_toggle_ocr` method was updating the button text and style before calling `_start_ocr()` or `_stop_ocr()`
- The `_start_ocr()` method included a call to center the mouse in the game window, which is time-consuming
- Multiple places in the code were directly modifying the OCR button properties instead of using a centralized approach
- The `AutomationTab` class was managing its OCR button state independently, leading to inconsistencies

### Solutions Implemented
- Refactored the `_toggle_ocr` method to immediately update the button state and then use a QTimer to perform the actual OCR operations asynchronously
- Created a centralized `_update_ocr_button_state` method to manage all OCR button state changes
- Updated the `keyPressEvent` method to use the new centralized method
- Added a `update_ocr_button_from_state` method to synchronize the button state with the actual OCR state
- Ensured that button state updates happen immediately, while potentially slow OCR operations happen asynchronously

### Future Prevention Strategies
- Always use asynchronous operations for potentially time-consuming tasks
- Centralize UI state management to avoid inconsistencies
- Use a clear separation between UI updates and backend operations
- Implement proper state synchronization mechanisms
- Add more comprehensive logging for state changes

## 2023-07-23: Fixed OCR Button State Inconsistency

### Issues Fixed
- OCR toggle button in the overlay tab had three states (green, red, and blueish) instead of just on/off
- Inconsistent button styling when toggling OCR via different methods (UI button vs. keyboard shortcuts)
- Button state not properly synchronized with the actual OCR state
- Escape/Q key not properly updating the OCR button style

### Root Cause Analysis
- Multiple code paths were updating the OCR button state with inconsistent styling
- The `keyPressEvent` method was only updating the button's checked state but not its text or style
- The AutomationTab class had its own OCR button with different styling
- Error handling in the `_toggle_ocr` method didn't properly update the button style

### Solutions Implemented
- Standardized the OCR button styling to use consistent colors (green for ON, red for OFF)
- Updated the `keyPressEvent` method to properly set the button text and style when stopping OCR
- Enhanced the `_toggle_ocr` method to ensure consistent button state management
- Updated the AutomationTab's OCR button styling to match the main OCR button
- Improved error handling to ensure the button always reflects the correct state
- Added more detailed logging to track OCR state changes

### Future Prevention Strategies
- Create helper methods for updating button states to ensure consistency
- Implement a centralized state management system for all toggleable processes
- Add unit tests to verify button state consistency across different activation methods
- Use a consistent approach for button styling throughout the application
- Ensure all error handling paths properly update UI elements

## 2023-07-21: Fixed Escape/Q Key Process Toggling

### Issues Fixed
- Escape/Q keys not properly toggling off template matching, OCR, and automation processes
- Button states not being updated when processes were stopped via keyboard shortcuts
- Inconsistent behavior between UI button clicks and keyboard shortcuts for stopping processes

### Root Cause Analysis
- The `keyPressEvent` method was calling the toggle methods but not updating the button states
- The toggle methods were not properly handling the state when triggered by keyboard shortcuts
- Error handling was insufficient in the toggle methods, potentially leaving processes in an inconsistent state

### Solutions Implemented
- Updated the `keyPressEvent` method to properly update button states before calling toggle methods
- Enhanced the `_toggle_pattern_matching` method to ensure button text and color are updated when toggled off
- Improved the `_toggle_ocr` method with better error handling and state management
- Added checks to ensure button states are consistent with the actual process states
- Ensured all toggle methods properly handle errors and set processes to OFF state in case of exceptions

### Future Prevention Strategies
- Implement a centralized process management system to ensure consistent state across UI and keyboard shortcuts
- Add unit tests for keyboard shortcut functionality
- Ensure all toggle methods follow the same pattern for state management and error handling
- Add more comprehensive logging for process state changes
- Consider adding a global state manager to track all active processes

## 2023-07-20: Fixed Stop Key Error in OCR Process

### Issues Fixed
- Error when pressing Escape key to stop OCR process: `AttributeError: 'OverlayController' object has no attribute '_handle_ocr_toggle'`
- Error when checking overlay status: `AttributeError: 'Overlay' object has no attribute 'is_active'. Did you mean: 'active'?`
- Error when checking sequence status: `AttributeError: 'AutomationTab' object has no attribute 'is_sequence_running'`
- Incorrect method names in the `keyPressEvent` handler causing stop functionality to fail

### Root Cause Analysis
- The `keyPressEvent` method was trying to call non-existent methods `_handle_ocr_toggle()` and `_handle_pattern_toggle()`
- The correct method names are `_toggle_ocr()` and `_toggle_pattern_matching()`
- The method was also checking for `self.overlay.is_active` when the attribute is actually named `active`
- The `AutomationTab` class didn't have a method called `is_sequence_running()` to check if a sequence was running
- These mismatches caused the application to crash when trying to stop processes using keyboard shortcuts

### Solutions Implemented
- Updated the `keyPressEvent` method to call the correct methods:
  - Changed `_handle_ocr_toggle()` to `_toggle_ocr()`
  - Changed `_handle_pattern_toggle()` to `_toggle_pattern_matching()`
- Fixed the attribute name check:
  - Changed `self.overlay.is_active` to `self.overlay.active`
- Added a new method to the `AutomationTab` class:
  - Added `is_sequence_running()` method that checks the sequence status text
- Updated the `keyPressEvent` method to safely check for the existence of the method before calling it
- Ensured proper error handling in the key event processing

### Future Prevention Strategies
- Implement consistent naming conventions for toggle methods and state attributes
- Add unit tests for keyboard shortcut functionality
- Ensure method references and attribute names are checked during code review
- Consider using a more robust event handling system for keyboard shortcuts
- Use IDE tools to verify attribute and method names before committing code
- Add proper interface documentation for classes to clarify available methods

## 2023-07-19: OCR Mouse Centering from Overlay Tab

### Issues Fixed
- Mouse not being centered when activating OCR from the overlay tab
- Inconsistent mouse positioning affecting OCR accuracy when started from different tabs

### Root Cause Analysis
- The `_start_ocr` method in the `OverlayController` class was not calling the mouse centering functionality
- Only the game world search tab was properly centering the mouse before OCR
- This led to inconsistent OCR results depending on which tab was used to start OCR

### Solutions Implemented
- Updated the `_start_ocr` method in the `OverlayController` class to center the mouse before starting OCR
- Added a call to the `game_coordinator.update_current_position_from_ocr()` method from the game world search tab
- Ensured proper error handling if the game world search tab is not available
- Added comprehensive logging to track the mouse centering process

### Future Prevention Strategies
- Ensure all OCR activation paths call the mouse centering functionality
- Centralize OCR activation to ensure consistent behavior
- Add proper error handling for all OCR-related operations
- Maintain detailed logging for all OCR activation paths

## 2023-07-18: Enhanced Mouse Centering for OCR

### Issues Fixed
- Mouse not properly centering in the game window before taking OCR screenshots
- Inconsistent mouse positioning affecting coordinate extraction
- OCR screenshots not capturing the correct region due to mouse position issues

### Root Cause Analysis
- The mouse centering method was not properly accounting for the window's client area vs. window frame
- Only two mouse movement methods were being used (win32api and pyautogui), with limited fallback options
- The window was not being activated before attempting to center the mouse
- The coordinate region calculation didn't account for window frame offsets

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement` method to use multiple mouse movement approaches:
  1. win32api.SetCursorPos
  2. ctypes.windll.user32.SetCursorPos
  3. pyautogui.moveTo
  4. ctypes.windll.user32.mouse_event (as a final fallback)
- Added verification after each mouse movement attempt to ensure the mouse actually moved to the target position
- Added the `_ensure_window_active` method to activate the game window before centering the mouse
- Updated the coordinate region calculation to account for window frame offsets
- Improved the client area detection to center the mouse in the actual game area, not just the window frame
- Added comprehensive logging to track mouse movement attempts and results

### Future Prevention Strategies
- Always verify mouse position after movement attempts
- Use multiple mouse movement methods with fallbacks
- Ensure the window is active before attempting mouse operations
- Account for window frame offsets when calculating positions
- Implement robust error handling and logging for all mouse operations

## 2023-07-17: Persistent Game World Coordinates

### Issues Fixed
- Game world coordinates being reset when OCR fails
- Template matching not using last valid coordinates when OCR fails
- Inconsistent coordinate handling across different components
- Coordinates not being maintained between OCR and template matching runs

### Root Cause Analysis
- The application was not properly maintaining the last valid coordinates
- OCR failures were causing coordinates to be lost or reset
- Different components (OCR, template matching) were not sharing coordinate information effectively
- No validation was performed before updating coordinates, allowing invalid values to be set

### Solutions Implemented
- Modified `GameState` class to maintain the last valid coordinates and never reset them unless explicitly told to do so
- Added validation to ensure only valid coordinates are stored
- Updated `TextOCR` class to always emit the latest coordinates, even if OCR fails
- Enhanced `GameWorldCoordinator` to use the last valid coordinates when OCR fails
- Updated `GameWorldSearch` to use the last valid coordinates from the game state when checking for templates
- Added comprehensive logging to track coordinate updates and usage

### Future Prevention Strategies
- Always validate coordinates before updating them
- Maintain a single source of truth for game coordinates (GameState)
- Ensure all components use the last valid coordinates when new ones can't be obtained
- Implement robust error handling for coordinate updates
- Add detailed logging for coordinate-related operations

## 2023-07-16: Continuous OCR Updates and Automatic Search Starting Point

### Issues Fixed
- Manual "Update Position" button was required to update search pattern parameters
- "Auto Update" toggle for coordinates was confusing and could be turned off
- Search patterns required manual specification of starting coordinates
- Mouse centering before OCR screenshots was not always reliable

### Root Cause Analysis
- The application had multiple ways to update coordinates, leading to inconsistency
- The coordinate update system was designed with manual intervention in mind
- Search patterns were using parameters from UI fields rather than always using current position
- Mouse centering needed additional verification and error handling

### Solutions Implemented
- Removed "Update Position" button from search controls
- Removed "Update Now" and "Auto Update" buttons from coordinate display
- Modified coordinate display to always update automatically
- Updated search functionality to always use current position from OCR as starting point
- Enhanced mouse centering with additional logging and verification
- Improved error handling in the OCR update process

### Future Prevention Strategies
- Maintain a single source of truth for game coordinates
- Ensure all components automatically use the latest coordinates
- Implement robust error handling and logging for all critical operations
- Design UI components with continuous updates in mind rather than manual intervention

## 2023-07-15: Mouse Centering and Search Button Fixes

### Issues Fixed
- Mouse not being centered before taking OCR screenshots
- Search/screenshot buttons in the game world search tab not functioning properly
- No visual feedback when updating position in the game world search tab

### Root Cause Analysis
- The `_center_mouse_for_measurement` method in `GameWorldCoordinator` was using only `pyautogui` for mouse movement, which can be unreliable
- The game world search tab lacked a dedicated button to update the current position
- The `update_current_position` method didn't provide user feedback on success or failure

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement` method to use `win32api` for more reliable mouse movement, with `pyautogui` as a fallback
- Added a "Update Position" button to the search controls widget to explicitly trigger position updates
- Improved the `update_current_position` method to provide visual feedback with success/failure messages
- Added wait cursor during position updates to indicate processing
- Enhanced logging throughout the position update process

### Future Prevention
- Use multiple mouse movement methods with fallbacks for greater reliability
- Always provide explicit UI controls for important actions
- Include visual feedback for long-running operations
- Implement comprehensive error handling and user feedback

## 2023-07-14: Strict Coordinate Format Enforcement

### Issues Fixed
- OCR system accepting invalid coordinate formats
- Inconsistent coordinate extraction due to lenient pattern matching
- Unnecessary text cleaning for game-specific OCR errors

### Root Cause Analysis
- The OCR system was too lenient in accepting various text formats as valid coordinates
- Text cleaning was attempting to handle too many edge cases, leading to false positives
- The scoring system wasn't prioritizing the expected format strongly enough

### Solutions Implemented
- Modified the coordinate extraction to strictly enforce the expected format of `K: 000 X: 000 Y: 000`
- Updated the text scoring system to heavily prioritize text matching the expected format
- Added a more specific OCR configuration to improve recognition of the expected format
- Simplified text cleaning to focus only on essential character replacements
- Added clear validation of coordinate values to ensure they are within valid ranges

### Future Prevention
- Maintain strict format validation for all coordinate extraction
- Use clear documentation about the expected coordinate format
- Implement comprehensive logging of rejected coordinate formats for debugging

## 2023-07-13: OCR Text Extraction Improvements

### Issues Fixed
- OCR failing to extract coordinates correctly from game UI
- Error in whitelist configuration causing OCR processing to fail
- Poor handling of common OCR misrecognitions in the game UI
- Inconsistent coordinate extraction from different preprocessing methods

### Root Cause Analysis
- The whitelist configuration had incorrect quotation marks causing a parsing error
- The text cleaning process wasn't handling common OCR errors specific to the game UI
- The scoring system for selecting the best OCR result wasn't robust enough
- The preprocessing methods weren't optimized for the game's coordinate display

### Solutions Implemented
- Fixed the whitelist configuration by removing problematic quotation marks
- Enhanced text cleaning to handle game-specific OCR errors (e.g., "geeX" instead of "X")
- Added a new preprocessing method using image sharpening for better text definition
- Improved the scoring system to better identify valid coordinate text
- Added more robust regex patterns for coordinate extraction
- Enhanced the text selection algorithm to skip invalid results and prioritize complete coordinates

### Future Prevention
- Added more comprehensive logging of OCR results and preprocessing steps
- Implemented better error handling in the OCR process
- Added more robust text cleaning and validation
- Ensured all OCR configuration strings are properly formatted

## 2023-07-12: OCR Method Selection Improvements

### Issues Fixed
- OCR producing inconsistent results with different preprocessing methods
- Need to prioritize the `thresh3` method which produces the best results
- No way to select which OCR preprocessing method to use

### Root Cause Analysis
- The OCR system was trying multiple preprocessing methods but not prioritizing the most reliable one
- The scoring system sometimes selected suboptimal results
- There was no UI option to select which preprocessing method to use

### Solutions Implemented
- Added a `preferred_method` property to the `TextOCR` class to specify which preprocessing method to prioritize
- Modified the `extract_text` method to prioritize results from the preferred method
- Added a dropdown menu to the OCR controls to select the preferred method
- Set `thresh3` (Otsu's thresholding) as the default method as it produces the best results
- Updated the `ConfigManager` to store and retrieve the preferred OCR method
- Added detailed logging of OCR results by method for better debugging

### Future Prevention
- Always provide UI options for critical processing parameters
- Implement proper fallback mechanisms when preferred methods fail
- Add detailed logging to help diagnose issues with different processing methods

## 2023-07-12: Mouse Movement and OCR Improvements

### Issues Fixed
- Mouse still not moving to center of screen before taking screenshots
- OCR not extracting coordinates from screenshots
- Coordinates not being displayed in the GUI
- Tesseract OCR path not properly configured

### Root Cause Analysis
- The `pyautogui` library might not be working correctly for mouse movement
- Tesseract OCR might not be properly installed or configured
- The coordinate region might not be capturing the area where coordinates are displayed in the game UI

### Solutions Implemented
- Modified the `_center_mouse_for_measurement` method to use `win32api` for mouse movement instead of `pyautogui`
- Added a fallback to try `pyautogui` if `win32api` fails
- Enhanced the `extract_text` method to check for Tesseract installation and provide better error handling
- Added automatic detection of Tesseract installation path
- Modified the coordinate region to try different areas of the screen (bottom left, bottom center, top right, etc.)
- Added a `try_all_coordinate_regions` method to systematically try different regions of the screen
- Modified the `_update_coordinates` method to try all coordinate regions if the initial update fails

### Future Prevention
- Use multiple mouse movement methods with fallbacks
- Always check for proper installation and configuration of external dependencies
- Try multiple screen regions when extracting information from the UI
- Add comprehensive error handling and logging

## 2023-07-11: Mouse Centering and Coordinate Extraction Fixes

### Issues Fixed
- Mouse not moving to the center of the screen before taking screenshots
- Coordinates not being extracted or displayed in the GUI
- Auto-update not enabled by default in the coordinate display widget

### Root Cause Analysis
- The mouse centering code in `GameWorldCoordinator._center_mouse_for_measurement()` was not properly verifying that the mouse had actually moved
- The delay after centering the mouse was too short, not giving the game UI enough time to update
- The coordinate display widget was not starting with auto-update enabled by default

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement()` method to verify mouse position after moving
- Added more detailed logging to track mouse movement and coordinate extraction
- Increased the delay after centering the mouse from 0.2 to 0.5 seconds
- Modified the `CoordinateDisplayWidget` to start with auto-update enabled by default
- Added a forced initial update to the coordinate display widget

### Future Prevention
- Always verify the results of mouse movement operations
- Add sufficient delays when interacting with the game UI
- Enable auto-update features by default when they are critical to functionality
- Add more detailed logging for debugging purposes

## 2023-07-11: Fixed GameCoordinates Import Error

### Issues Fixed
- Application failing to start due to `NameError: name 'GameCoordinates' is not defined` in `text_ocr.py`

### Root Cause Analysis
- The `_extract_coordinates` method in `TextOCR` class was updated to return `Optional[GameCoordinates]`, but the `GameCoordinates` class wasn't properly imported from `game_state.py`

### Solutions Implemented
- Added proper import statement: `from scout.game_state import GameState, GameCoordinates`

### Future Prevention
- Always ensure that all type annotations have corresponding imports
- Run a quick test after making changes to ensure the application starts correctly

## 2023-07-11: Coordinate Extraction and Stop Key Functionality

### Issues Fixed
- Coordinates not being consistently extracted and displayed in the GUI
- No way to stop OCR and other processes using keyboard shortcuts
- Inconsistent coordinate display when OCR fails
- Insufficient logging for debugging OCR issues

### Root Cause Analysis
- The OCR system had multiple signal paths that weren't properly connected
- The `_on_coordinates_updated` method in `GameWorldSearchTab` wasn't properly updating the UI
- The `_update_coordinates` method in `CoordinateDisplayWidget` didn't handle OCR failures gracefully
- The `_process_region` and `_extract_coordinates` methods in `TextOCR` weren't properly emitting signals
- No global key event handling for stopping processes

### Solutions Implemented
- Added a `keyPressEvent` method to the `OverlayController` class to handle Escape and Q key presses
- Enhanced the `_on_coordinates_updated` method in `GameWorldSearchTab` to ensure it properly updates the UI
- Improved the `_update_coordinates` method in `CoordinateDisplayWidget` to handle different coordinate sources
- Enhanced the `_process_region` and `_extract_coordinates` methods in `TextOCR` to ensure proper signal emission
- Added more comprehensive logging throughout the OCR process for better debugging
- Improved error handling in coordinate extraction and display
- Added fallback to display last known coordinates when OCR fails

### Future Prevention
- Maintain consistent signal connections between OCR system and UI components
- Ensure all key UI components have proper error handling and fallbacks
- Add comprehensive logging for all critical operations
- Implement global key event handling for common operations like stopping processes

## 2023-07-10: OCR System Integration

### Issues Fixed
- Inconsistent OCR processing paths leading to unreliable coordinate extraction
- Duplicate OCR logic in `GameWorldCoordinator.update_current_position_from_ocr()` and `TextOCR._process_region()`
- Inconsistent debug screenshot naming making it difficult to compare results
- Coordinate display not updating properly in the game world search tab

### Root Cause Analysis
- The OCR system had two separate processing paths:
  1. `TextOCR._process_region()` - Used by the "old" OCR system
  2. `GameWorldCoordinator.update_current_position_from_ocr()` - Used by the game world search system
- These paths used different methods for capturing screenshots, processing images, and extracting coordinates
- Debug screenshots were saved with inconsistent names
- The game world search tab wasn't properly connected to the OCR system's signals

### Solutions Implemented
- Unified OCR processing paths to ensure consistent coordinate extraction
- Modified `GameWorldCoordinator.update_current_position_from_ocr()` to use `TextOCR._process_region()`
- Updated `TextOCR._process_region()` to save debug images with consistent naming
- Connected the `coordinates_updated` signal from `TextOCR` to the `_on_coordinates_updated` method in `GameWorldSearchTab`

### Future Prevention
- Maintain a single source of truth for OCR processing
- Use consistent naming for debug images
- Ensure all UI components are properly connected to the OCR system's signals

## OCR System and Game World Search Integration (2023-07-10)

### Issues Fixed
- Inconsistent OCR processing paths causing coordinate extraction failures
- Missing screenshots during template searches making debugging difficult
- Coordinate display not updating properly in the game world search tab
- Game world coordinator not properly utilizing the TextOCR system

### Root Cause Analysis
The main issue was that there were two separate processing paths for OCR:
1. `TextOCR._process_region()` - Used by the main OCR system
2. `GameWorldCoordinator.update_current_position_from_ocr()` - Used by the game world search system

This dual approach led to inconsistent results, as the game world search system was not properly integrated with the OCR system. Additionally, screenshots were not being consistently saved during template searches, making it difficult to debug coordinate extraction issues.

### Solutions Implemented
1. Modified `GameWorldCoordinator.update_current_position_from_ocr()` to use the TextOCR system directly
2. Enhanced `GameWorldSearch._check_for_templates()` to always save screenshots for debugging
3. Improved `CoordinateDisplayWidget._update_coordinates()` to handle different coordinate sources
4. Added additional logging and debug screenshots for better troubleshooting
5. Ensured the game world search tab properly updates when coordinates change

### Future Prevention
- Maintain a single source of truth for OCR processing
- Use consistent naming for debug images
- Ensure all UI components are properly connected to the OCR system's signals
- Add more comprehensive logging for coordinate updates
- Implement better error handling for OCR failures

## 2023-08-01: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-02: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-03: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-04: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-05: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-06: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-07: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-08: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-09: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-10: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-11: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-12: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-13: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-14: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-15: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-16: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-17: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-18: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-19: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-20: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-21: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-22: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-23: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-24: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-25: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-26: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-27: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-08-28: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-08-29: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-30: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-08-31: Fixed OCR Process Getting Stuck When Using Escape/Q Keys

### Issues Fixed
- Application getting stuck when trying to escape/q out of the OCR process
- OCR process not responding to cancellation requests
- UI becoming unresponsive during OCR operations

### Root Cause Analysis
- The OCR process in `TextOCR._process_region()` and `extract_text()` methods had no mechanism to check for cancellation requests during execution
- The `pytesseract` library operations could not be interrupted once started
- The key press event handler in `gui_controller.py` was not properly setting cancellation flags before stopping the OCR process
- Timeout mechanisms were not properly integrated with cancellation flags

### Solutions Implemented
1. Added a cancellation flag to the `TextOCR` class:
   - Added `_cancellation_requested` flag to track cancellation requests
   - Modified `start()` method to reset the flag
   - Modified `stop()` method to set the flag
2. Enhanced the `_process_region()` method to check for cancellation:
   - Added checks at key points in the method to exit early if cancellation is requested
   - Added logging to track cancellation events
3. Modified the `extract_text()` method to check for cancellation:
   - Added check at the beginning of the method to exit early if cancellation is requested
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag directly before calling `_stop_ocr()`
   - Added immediate UI feedback when cancellation is requested
5. Enhanced the `_stop_ocr()` method to ensure proper cancellation:
   - Set cancellation flag before disconnecting signals
   - Added error handling for signal disconnection
   - Ensured button state is properly updated
6. Modified the `_toggle_ocr()` and `_perform_ocr_toggle()` methods:
   - Set cancellation flag immediately when turning off OCR
   - Reset cancellation flag when starting OCR
7. Updated the `update_current_position_from_ocr()` method in `GameWorldCoordinator`:
   - Added check for cancellation flag
   - Added early return if cancellation is requested
8. Enhanced the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Added checks for cancellation flag
   - Set cancellation flag if timeout is reached
   - Added proper UI feedback for cancellation events

### Prevention Strategies
1. Implemented a comprehensive cancellation mechanism throughout the OCR process
2. Added multiple cancellation check points in long-running operations
3. Ensured proper UI feedback for cancellation events
4. Integrated timeout mechanisms with cancellation flags
5. Added detailed logging for cancellation events

### Testing
1. Verified that the application properly responds to Escape/Q keys during OCR operations
2. Confirmed that the OCR process stops immediately when cancellation is requested
3. Tested that the UI remains responsive during OCR operations
4. Verified that proper error messages are displayed when OCR is cancelled
5. Confirmed that auto-update is properly stopped when OCR is cancelled

## 2023-09-01: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## 2023-09-02: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-09-03: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system

## 2023-09-04: Fixed Excessive OCR Updates and Mouse Centering

### Issues Fixed
- Application constantly updating OCR too frequently
- Mouse constantly being reset to the center of the game window
- OCR process still not responding properly to Escape/Q keys
- Auto-update in coordinate widget causing excessive OCR operations

### Root Cause Analysis
- Rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()` was too short (0.5 seconds)
- Auto-update interval in `CoordinateDisplayWidget` was too short (2 seconds)
- Auto-update was sometimes enabled by default or not properly disabled when OCR was stopped
- Cancellation mechanism wasn't aggressive enough to stop all OCR-related processes
- Timeout checks weren't frequent enough to detect cancellation requests quickly

### Solutions Implemented
1. Increased rate limiting in `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Changed from 0.5 seconds to 2.0 seconds to prevent excessive updates
2. Modified `CoordinateDisplayWidget` to improve auto-update behavior:
   - Increased auto-update interval from 2 seconds to 5 seconds
   - Ensured auto-update is disabled by default
   - Added more frequent cancellation checks during updates
3. Enhanced the `TextOCR.stop()` method:
   - Added a verification step to ensure OCR is fully stopped
   - Added a delayed check to force stop if still active
4. Improved the key press event handler in `gui_controller.py`:
   - Set cancellation flag immediately on key press
   - Added code to stop coordinate widget auto-update when OCR is stopped
5. Enhanced the `_stop_ocr()` method:
   - Added code to stop coordinate widget auto-update
   - Added a verification step to ensure OCR is fully stopped
6. Added a new `_verify_ocr_stopped()` method to `OverlayController`:
   - Checks if OCR is still active after stop request
   - Forces stop if OCR is still active
   - Updates UI to reflect forced stop
7. Modified the `_update_coordinates()` method in `CoordinateDisplayWidget`:
   - Reduced timeout from 5 seconds to 3 seconds
   - Increased frequency of timeout checks from 500ms to 200ms
   - Added more cancellation checks during the update process

### Prevention Strategies
1. Implemented more aggressive rate limiting to prevent excessive OCR updates
2. Added multiple verification steps to ensure OCR is fully stopped
3. Ensured auto-update is properly disabled when OCR is stopped
4. Added more frequent cancellation checks during OCR operations
5. Improved coordination between different components that use OCR

### Testing
1. Verified that OCR updates occur at a reasonable frequency
2. Confirmed that the mouse is not constantly being centered
3. Tested that Escape/Q keys properly stop all OCR-related processes
4. Verified that auto-update is properly disabled when OCR is stopped
5. Confirmed that the application remains responsive during OCR operations

## Calibration Display Inconsistency (Fixed)
**Date:** March 1, 2024
**Status:** FIXED

### Issue Description
The calibration results were displaying inconsistent values between the GUI widgets and the logs. Specifically:
- The East direction values were showing different results in different parts of the UI
- The wrapped distance calculations were not consistently applied across all display locations
- The ratios shown in the GUI didn't match the actual calculations in the logs

### Root Cause
1. Different widgets (DirectionWidget and CoordinateDisplayWidget) were using different methods to calculate and display the calibration results
2. The wrapped distance calculation was not consistently implemented across all display locations
3. The GUI wasn't showing the detailed movement information that was available in the logs

### Solution
1. Updated both DirectionWidget and CoordinateDisplayWidget to:
   - Use the same wrapped distance calculation logic
   - Show consistent ratio calculations
   - Display detailed movement information
2. Improved the display format to show:
   - Raw screen distances
   - Absolute game unit values
   - Calculated ratios for both directions
3. Added validation for screen distances against window dimensions
4. Enhanced logging to show more detailed movement information

### Implementation Details
1. Modified DirectionWidget._start_calibration():
   - Added proper wrapped distance calculation
   - Improved progress feedback
   - Enhanced results display with ratios
2. Updated CoordinateDisplayWidget._update_calibration_display():
   - Added detailed movement information
   - Implemented consistent distance calculations
   - Improved results formatting
3. Both widgets now show:
   - Screen distances in pixels
   - Game unit movements with proper wrapping
   - Calculated ratios for verification

### Verification
- Calibration results now match between:
  - Log output
  - DirectionWidget display
  - CoordinateDisplayWidget display
- All displays show the same:
  - Screen distances
  - Game unit movements
  - Pixels per game unit ratios

### Prevention
To prevent similar issues in the future:
1. Always implement consistent calculation methods across all display locations
2. Use the same validation and wrapping logic throughout the application
3. Show detailed information in the GUI to match log output
4. Validate displayed values against actual calculations

## [FIXED] Inconsistent Y Measurements in Direction Calibration
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldDirection

### Issue Description
During direction calibration, the first Y measurement was consistently higher (~23%) than subsequent measurements, causing calibration failures due to inconsistent ratios.

### Root Cause
The game world was not fully stabilized after movements before taking measurements. The first measurement was affected by residual movement in the game world.

### Solution
Modified the `_calibrate_direction` method in `game_world_direction.py` to:
1. Increase initial wait time from 1.0s to 1.5s
2. Add multiple OCR updates (3 times with 0.5s delay) at each critical point:
   - Before taking the start position
   - After the drag movement
   - After returning to start position
3. Increase wait time after movements from 1.5s to 2.0s

### Verification
- Y measurements are now consistent across all runs
- Calibration completes successfully with consistent ratios
- No more outliers in the first measurement 

## [FIXED] OCR Region Out of Window Bounds
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR was failing to read coordinates because the OCR region was being positioned outside the game window bounds, particularly when the window was moved or resized.

### Root Cause
The OCR region coordinates were not being properly validated against window bounds, and physical screen coordinates were not being updated when the window moved.

### Solution
1. Enhanced `set_region` method in `TextOCR` class to:
   - Add bounds checking to ensure region stays within window
   - Store both logical (window-relative) and physical (screen) coordinates
   - Improve error handling and validation
2. Updated `_process_region` method to:
   - Dynamically update physical coordinates based on current window position
   - Add bounds checking during processing
   - Improve screenshot saving for debugging
   - Enhance error handling and logging

### Verification
- OCR region now stays within game window bounds
- Region automatically adjusts when window moves
- Coordinates are properly read during scans
- Debug screenshots are saved for verification 

## [FIXED] Missing Screenshot Capture Method
**Date:** March 1, 2024
**Status:** FIXED
**Component:** WindowManager, TextOCR

### Issue Description
OCR system was broken in both overlay and game world tab due to a missing `capture_region` method in the WindowManager class.

### Root Cause
During the OCR system refactoring, we moved the screenshot capture functionality from TextOCR to WindowManager for better organization, but the implementation of `capture_region` was missing.

### Solution
1. Added `capture_region` method to WindowManager:
   - Takes region dictionary with left, top, width, height
   - Uses mss for efficient screen capture
   - Converts BGRA to BGR format for OpenCV compatibility
   - Includes proper error handling
2. Added necessary imports:
   - numpy for array handling
   - cv2 for image processing
   - mss for screen capture

### Verification
- OCR system now works in both overlay and game world tab
- Screenshots are properly captured and processed
- Color format is correctly converted for OpenCV
- Error handling properly catches and logs issues 

## [FIXED] OCR Region Update and Game State Sync
**Date:** March 1, 2024
**Status:** FIXED
**Component:** TextOCR

### Issue Description
OCR system was failing to properly update coordinates and maintain game state synchronization after the screenshot capture refactoring.

### Root Cause
1. Physical region updates were not properly maintaining all required fields
2. Game state was not being updated with new coordinates
3. Region dictionary was being modified in place instead of being recreated

### Solution
1. Fixed physical region updates in TextOCR:
   - Now creating new region dictionary with all fields
   - Properly calculating screen coordinates from window position
   - Maintaining dpi_scale and other required properties
2. Added game state synchronization:
   - Updating game state when new coordinates are extracted
   - Ensuring coordinates are properly formatted
3. Improved error handling and logging:
   - Better debug messages for troubleshooting
   - Clearer logging of coordinate extraction results

### Verification
- OCR system now properly updates coordinates
- Game state stays synchronized with latest coordinates
- Debug screenshots are properly saved
- Error handling provides clear feedback 

## [FIXED] Game World Search Functionality
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search functionality was failing due to:
1. Missing `get_game_position` method
2. PyDirectInput fail-safe triggering from excessive mouse movement
3. Incorrect drag vector calculation

### Root Cause
1. The `get_game_position` method was referenced but not implemented
2. Drag vectors were being calculated without proper bounds checking
3. Mouse movements were attempting to move outside window bounds

### Solution
1. Added `get_game_position` method:
   - Calculates game world position from grid coordinates
   - Uses start position and drag distances
   - Handles coordinate wrapping properly
2. Improved drag vector calculation:
   - Added proper scaling based on window dimensions
   - Implemented bounds checking for drag coordinates
   - Centered drags around window center
3. Enhanced movement logic:
   - Added relative window coordinates for drags
   - Implemented proper coordinate wrapping
   - Added better error handling and logging

### Verification
- Search functionality now works correctly
- Mouse movements stay within window bounds
- Grid positions are properly calculated
- Drag operations complete successfully 

## [FIXED] Search Movement Using Calibrated Drag Points
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch

### Issue Description
Search movement was not using the calibrated drag points from direction definitions, leading to inconsistent movement and potential errors.

### Root Cause
The `_move_to_position` method was calculating its own drag points based on window dimensions instead of using the calibrated points from direction definitions.

### Solution
Modified `_move_to_position` method to:
1. Use calibrated drag points:
   - North/South drags use points from north definition
   - East/West drags use points from east definition
2. Calculate number of drags needed:
   - Based on target distance and calibrated drag distances
   - Handles both positive and negative movements
3. Perform drags in sequence:
   - First east/west movement
   - Then north/south movement
   - Uses proper inverse points for opposite directions

### Verification
- Search movement now uses calibrated drag points
- Movement is consistent with calibration
- Proper handling of both directions
- Correct use of inverse points for opposite movements

## [FIXED] Game World Search Movement System
**Date:** March 1, 2024
**Status:** FIXED
**Component:** GameWorldSearch, GameWorldCoordinator, GameWorldDirection

### Issue Description
The game world search movement system was failing with the error "'GameWorldCoordinator' object has no attribute 'direction_system'". The movement was not using the calibrated drag points from direction definitions.

### Root Cause
1. GameWorldCoordinator was not properly connected to the direction system
2. Movement calculations were not using calibrated drag distances
3. Missing proper handling of direction system initialization

### Solution
1. Added direction_system attribute to GameWorldCoordinator
2. Updated GameWorldDirection to set itself as the coordinator's direction system
3. Rewritten _move_to_position method to:
   - Use calibrated drag points from direction definitions
   - Calculate proper drag distances based on direction definitions
   - Handle both positive and negative movements correctly
   - Use proper inverse points for opposite directions
4. Added _perform_drag helper method for consistent drag operations

### Verification
- Movement now uses calibrated drag points
- Proper calculation of drag distances
- Correct handling of positive/negative movements
- Position updates after each drag
- Proper error handling and logging

### Grid Update Fix - March 1, 2024

**Issue**: Grid view was not updating properly during game world search.

**Root Cause**:
1. Grid updates were not properly synchronized with position updates
2. Game coordinator position updates were not being called consistently
3. Grid status was not being refreshed after position changes

**Fix**:
1. Modified `_update_search_status` in `game_world_search_tab.py`:
   - Added proper game position retrieval
   - Ensured grid status updates after position changes
   - Fixed coordinate passing to grid widget methods

2. Enhanced `_move_to_position` in `game_world_search.py`:
   - Added coordinate update waits after each drag
   - Added explicit game coordinator position updates
   - Added final position update after movement completion

**Verification**:
- Grid now updates correctly during search
- Position tracking is more accurate
- Grid status reflects current search state

### Key Handling and Grid Update Improvements - March 1, 2024

**Issue 1**: Q/Escape key not reliably stopping search when game window has focus
**Issue 2**: Search grid widget not updating properly during search

**Root Cause**:
1. Key Handling:
   - Key check interval too long
   - Window focus issues when game window active
   - Inconsistent cleanup of timers

2. Grid Updates:
   - Updates not properly synchronized with search status
   - Grid state not properly initialized at search start
   - Update frequency too low during search

**Fix**:
1. Key Handling Improvements:
   - Reduced key check timer interval to 50ms for better responsiveness
   - Added periodic window focus management
   - Added forced window focus when stopping search
   - Improved timer cleanup

2. Grid Update Enhancements:
   - Connected grid status_updated signal to UI updates
   - Increased grid update frequency during search (250ms)
   - Added proper grid parameter initialization at search start
   - Added forced grid updates at key points
   - Improved grid state management
   - Enhanced error handling and logging

**Verification**:
1. Key Handling:
   - Q/Escape keys now respond more quickly
   - Search can be stopped even when game window has focus
   - Window focus properly managed during search

2. Grid Updates:
   - Grid now updates consistently during search
   - Grid state properly reflects current search progress
   - Grid updates more responsive
   - Grid status properly displayed

**Next Steps**:
1. Monitor key handling performance
2. Consider adding visual feedback when stop keys are pressed
3. Consider adding configurable key check interval
4. Monitor grid update performance
5. Consider adding grid animation for smoother updates

## Game World Grid Initialization Error (Fixed)

**Issue**: KeyError when trying to access view position during initialization
- Error occurred in `_center_on_current_view` when trying to access `view_positions[self.current_view]`
- Root cause: View position wasn't properly initialized before centering attempt

**Fix**:
1. Added validation in `_center_on_current_view` to check if view position exists
2. Modified initialization flow in `set_grid_parameters` and `update_grid_parameters`
3. Ensured proper view state and position initialization
4. Removed grid-based code and updated to view-based approach

**Changes**:
- Added position existence check before access
- Updated initialization methods to properly set up view state
- Removed unused grid-based code
- Improved error handling and validation

**Status**: Fixed
**Date**: [Current Date]
