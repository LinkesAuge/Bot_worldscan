---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---
# Bug Fixing Log

## 2023-07-24: Fixed OCR Button Text Update Delay

### Issues Fixed
- OCR button text in the overlay tab had a significant delay when toggling between ON/OFF states
- Button state updates were blocked by time-consuming OCR operations
- Inconsistent button state management across different parts of the application

### Root Cause Analysis
- The `_toggle_ocr` method was updating the button text and style before calling `_start_ocr()` or `_stop_ocr()`
- The `_start_ocr()` method included a call to center the mouse in the game window, which is time-consuming
- Multiple places in the code were directly modifying the OCR button properties instead of using a centralized approach
- The `AutomationTab` class was managing its OCR button state independently, leading to inconsistencies

### Solutions Implemented
- Refactored the `_toggle_ocr` method to immediately update the button state and then use a QTimer to perform the actual OCR operations asynchronously
- Created a centralized `_update_ocr_button_state` method to manage all OCR button state changes
- Updated the `keyPressEvent` method to use the new centralized method
- Added a `update_ocr_button_from_state` method to synchronize the button state with the actual OCR state
- Ensured that button state updates happen immediately, while potentially slow OCR operations happen asynchronously

### Future Prevention Strategies
- Always use asynchronous operations for potentially time-consuming tasks
- Centralize UI state management to avoid inconsistencies
- Use a clear separation between UI updates and backend operations
- Implement proper state synchronization mechanisms
- Add more comprehensive logging for state changes

## 2023-07-23: Fixed OCR Button State Inconsistency

### Issues Fixed
- OCR toggle button in the overlay tab had three states (green, red, and blueish) instead of just on/off
- Inconsistent button styling when toggling OCR via different methods (UI button vs. keyboard shortcuts)
- Button state not properly synchronized with the actual OCR state
- Escape/Q key not properly updating the OCR button style

### Root Cause Analysis
- Multiple code paths were updating the OCR button state with inconsistent styling
- The `keyPressEvent` method was only updating the button's checked state but not its text or style
- The AutomationTab class had its own OCR button with different styling
- Error handling in the `_toggle_ocr` method didn't properly update the button style

### Solutions Implemented
- Standardized the OCR button styling to use consistent colors (green for ON, red for OFF)
- Updated the `keyPressEvent` method to properly set the button text and style when stopping OCR
- Enhanced the `_toggle_ocr` method to ensure consistent button state management
- Updated the AutomationTab's OCR button styling to match the main OCR button
- Improved error handling to ensure the button always reflects the correct state
- Added more detailed logging to track OCR state changes

### Future Prevention Strategies
- Create helper methods for updating button states to ensure consistency
- Implement a centralized state management system for all toggleable processes
- Add unit tests to verify button state consistency across different activation methods
- Use a consistent approach for button styling throughout the application
- Ensure all error handling paths properly update UI elements

## 2023-07-21: Fixed Escape/Q Key Process Toggling

### Issues Fixed
- Escape/Q keys not properly toggling off template matching, OCR, and automation processes
- Button states not being updated when processes were stopped via keyboard shortcuts
- Inconsistent behavior between UI button clicks and keyboard shortcuts for stopping processes

### Root Cause Analysis
- The `keyPressEvent` method was calling the toggle methods but not updating the button states
- The toggle methods were not properly handling the state when triggered by keyboard shortcuts
- Error handling was insufficient in the toggle methods, potentially leaving processes in an inconsistent state

### Solutions Implemented
- Updated the `keyPressEvent` method to properly update button states before calling toggle methods
- Enhanced the `_toggle_pattern_matching` method to ensure button text and color are updated when toggled off
- Improved the `_toggle_ocr` method with better error handling and state management
- Added checks to ensure button states are consistent with the actual process states
- Ensured all toggle methods properly handle errors and set processes to OFF state in case of exceptions

### Future Prevention Strategies
- Implement a centralized process management system to ensure consistent state across UI and keyboard shortcuts
- Add unit tests for keyboard shortcut functionality
- Ensure all toggle methods follow the same pattern for state management and error handling
- Add more comprehensive logging for process state changes
- Consider adding a global state manager to track all active processes

## 2023-07-20: Fixed Stop Key Error in OCR Process

### Issues Fixed
- Error when pressing Escape key to stop OCR process: `AttributeError: 'OverlayController' object has no attribute '_handle_ocr_toggle'`
- Error when checking overlay status: `AttributeError: 'Overlay' object has no attribute 'is_active'. Did you mean: 'active'?`
- Error when checking sequence status: `AttributeError: 'AutomationTab' object has no attribute 'is_sequence_running'`
- Incorrect method names in the `keyPressEvent` handler causing stop functionality to fail

### Root Cause Analysis
- The `keyPressEvent` method was trying to call non-existent methods `_handle_ocr_toggle()` and `_handle_pattern_toggle()`
- The correct method names are `_toggle_ocr()` and `_toggle_pattern_matching()`
- The method was also checking for `self.overlay.is_active` when the attribute is actually named `active`
- The `AutomationTab` class didn't have a method called `is_sequence_running()` to check if a sequence was running
- These mismatches caused the application to crash when trying to stop processes using keyboard shortcuts

### Solutions Implemented
- Updated the `keyPressEvent` method to call the correct methods:
  - Changed `_handle_ocr_toggle()` to `_toggle_ocr()`
  - Changed `_handle_pattern_toggle()` to `_toggle_pattern_matching()`
- Fixed the attribute name check:
  - Changed `self.overlay.is_active` to `self.overlay.active`
- Added a new method to the `AutomationTab` class:
  - Added `is_sequence_running()` method that checks the sequence status text
- Updated the `keyPressEvent` method to safely check for the existence of the method before calling it
- Ensured proper error handling in the key event processing

### Future Prevention Strategies
- Implement consistent naming conventions for toggle methods and state attributes
- Add unit tests for keyboard shortcut functionality
- Ensure method references and attribute names are checked during code review
- Consider using a more robust event handling system for keyboard shortcuts
- Use IDE tools to verify attribute and method names before committing code
- Add proper interface documentation for classes to clarify available methods

## 2023-07-19: OCR Mouse Centering from Overlay Tab

### Issues Fixed
- Mouse not being centered when activating OCR from the overlay tab
- Inconsistent mouse positioning affecting OCR accuracy when started from different tabs

### Root Cause Analysis
- The `_start_ocr` method in the `OverlayController` class was not calling the mouse centering functionality
- Only the game world search tab was properly centering the mouse before OCR
- This led to inconsistent OCR results depending on which tab was used to start OCR

### Solutions Implemented
- Updated the `_start_ocr` method in the `OverlayController` class to center the mouse before starting OCR
- Added a call to the `game_coordinator.update_current_position_from_ocr()` method from the game world search tab
- Ensured proper error handling if the game world search tab is not available
- Added comprehensive logging to track the mouse centering process

### Future Prevention Strategies
- Ensure all OCR activation paths call the mouse centering functionality
- Centralize OCR activation to ensure consistent behavior
- Add proper error handling for all OCR-related operations
- Maintain detailed logging for all OCR activation paths

## 2023-07-18: Enhanced Mouse Centering for OCR

### Issues Fixed
- Mouse not properly centering in the game window before taking OCR screenshots
- Inconsistent mouse positioning affecting coordinate extraction
- OCR screenshots not capturing the correct region due to mouse position issues

### Root Cause Analysis
- The mouse centering method was not properly accounting for the window's client area vs. window frame
- Only two mouse movement methods were being used (win32api and pyautogui), with limited fallback options
- The window was not being activated before attempting to center the mouse
- The coordinate region calculation didn't account for window frame offsets

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement` method to use multiple mouse movement approaches:
  1. win32api.SetCursorPos
  2. ctypes.windll.user32.SetCursorPos
  3. pyautogui.moveTo
  4. ctypes.windll.user32.mouse_event (as a final fallback)
- Added verification after each mouse movement attempt to ensure the mouse actually moved to the target position
- Added the `_ensure_window_active` method to activate the game window before centering the mouse
- Updated the coordinate region calculation to account for window frame offsets
- Improved the client area detection to center the mouse in the actual game area, not just the window frame
- Added comprehensive logging to track mouse movement attempts and results

### Future Prevention Strategies
- Always verify mouse position after movement attempts
- Use multiple mouse movement methods with fallbacks
- Ensure the window is active before attempting mouse operations
- Account for window frame offsets when calculating positions
- Implement robust error handling and logging for all mouse operations

## 2023-07-17: Persistent Game World Coordinates

### Issues Fixed
- Game world coordinates being reset when OCR fails
- Template matching not using last valid coordinates when OCR fails
- Inconsistent coordinate handling across different components
- Coordinates not being maintained between OCR and template matching runs

### Root Cause Analysis
- The application was not properly maintaining the last valid coordinates
- OCR failures were causing coordinates to be lost or reset
- Different components (OCR, template matching) were not sharing coordinate information effectively
- No validation was performed before updating coordinates, allowing invalid values to be set

### Solutions Implemented
- Modified `GameState` class to maintain the last valid coordinates and never reset them unless explicitly told to do so
- Added validation to ensure only valid coordinates are stored
- Updated `TextOCR` class to always emit the latest coordinates, even if OCR fails
- Enhanced `GameWorldCoordinator` to use the last valid coordinates when OCR fails
- Updated `GameWorldSearch` to use the last valid coordinates from the game state when checking for templates
- Added comprehensive logging to track coordinate updates and usage

### Future Prevention Strategies
- Always validate coordinates before updating them
- Maintain a single source of truth for game coordinates (GameState)
- Ensure all components use the last valid coordinates when new ones can't be obtained
- Implement robust error handling for coordinate updates
- Add detailed logging for coordinate-related operations

## 2023-07-16: Continuous OCR Updates and Automatic Search Starting Point

### Issues Fixed
- Manual "Update Position" button was required to update search pattern parameters
- "Auto Update" toggle for coordinates was confusing and could be turned off
- Search patterns required manual specification of starting coordinates
- Mouse centering before OCR screenshots was not always reliable

### Root Cause Analysis
- The application had multiple ways to update coordinates, leading to inconsistency
- The coordinate update system was designed with manual intervention in mind
- Search patterns were using parameters from UI fields rather than always using current position
- Mouse centering needed additional verification and error handling

### Solutions Implemented
- Removed "Update Position" button from search controls
- Removed "Update Now" and "Auto Update" buttons from coordinate display
- Modified coordinate display to always update automatically
- Updated search functionality to always use current position from OCR as starting point
- Enhanced mouse centering with additional logging and verification
- Improved error handling in the OCR update process

### Future Prevention Strategies
- Maintain a single source of truth for game coordinates
- Ensure all components automatically use the latest coordinates
- Implement robust error handling and logging for all critical operations
- Design UI components with continuous updates in mind rather than manual intervention

## 2023-07-15: Mouse Centering and Search Button Fixes

### Issues Fixed
- Mouse not being centered before taking OCR screenshots
- Search/screenshot buttons in the game world search tab not functioning properly
- No visual feedback when updating position in the game world search tab

### Root Cause Analysis
- The `_center_mouse_for_measurement` method in `GameWorldCoordinator` was using only `pyautogui` for mouse movement, which can be unreliable
- The game world search tab lacked a dedicated button to update the current position
- The `update_current_position` method didn't provide user feedback on success or failure

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement` method to use `win32api` for more reliable mouse movement, with `pyautogui` as a fallback
- Added a "Update Position" button to the search controls widget to explicitly trigger position updates
- Improved the `update_current_position` method to provide visual feedback with success/failure messages
- Added wait cursor during position updates to indicate processing
- Enhanced logging throughout the position update process

### Future Prevention
- Use multiple mouse movement methods with fallbacks for greater reliability
- Always provide explicit UI controls for important actions
- Include visual feedback for long-running operations
- Implement comprehensive error handling and user feedback

## 2023-07-14: Strict Coordinate Format Enforcement

### Issues Fixed
- OCR system accepting invalid coordinate formats
- Inconsistent coordinate extraction due to lenient pattern matching
- Unnecessary text cleaning for game-specific OCR errors

### Root Cause Analysis
- The OCR system was too lenient in accepting various text formats as valid coordinates
- Text cleaning was attempting to handle too many edge cases, leading to false positives
- The scoring system wasn't prioritizing the expected format strongly enough

### Solutions Implemented
- Modified the coordinate extraction to strictly enforce the expected format of `K: 000 X: 000 Y: 000`
- Updated the text scoring system to heavily prioritize text matching the expected format
- Added a more specific OCR configuration to improve recognition of the expected format
- Simplified text cleaning to focus only on essential character replacements
- Added clear validation of coordinate values to ensure they are within valid ranges

### Future Prevention
- Maintain strict format validation for all coordinate extraction
- Use clear documentation about the expected coordinate format
- Implement comprehensive logging of rejected coordinate formats for debugging

## 2023-07-13: OCR Text Extraction Improvements

### Issues Fixed
- OCR failing to extract coordinates correctly from game UI
- Error in whitelist configuration causing OCR processing to fail
- Poor handling of common OCR misrecognitions in the game UI
- Inconsistent coordinate extraction from different preprocessing methods

### Root Cause Analysis
- The whitelist configuration had incorrect quotation marks causing a parsing error
- The text cleaning process wasn't handling common OCR errors specific to the game UI
- The scoring system for selecting the best OCR result wasn't robust enough
- The preprocessing methods weren't optimized for the game's coordinate display

### Solutions Implemented
- Fixed the whitelist configuration by removing problematic quotation marks
- Enhanced text cleaning to handle game-specific OCR errors (e.g., "geeX" instead of "X")
- Added a new preprocessing method using image sharpening for better text definition
- Improved the scoring system to better identify valid coordinate text
- Added more robust regex patterns for coordinate extraction
- Enhanced the text selection algorithm to skip invalid results and prioritize complete coordinates

### Future Prevention
- Added more comprehensive logging of OCR results and preprocessing steps
- Implemented better error handling in the OCR process
- Added more robust text cleaning and validation
- Ensured all OCR configuration strings are properly formatted

## 2023-07-12: OCR Method Selection Improvements

### Issues Fixed
- OCR producing inconsistent results with different preprocessing methods
- Need to prioritize the `thresh3` method which produces the best results
- No way to select which OCR preprocessing method to use

### Root Cause Analysis
- The OCR system was trying multiple preprocessing methods but not prioritizing the most reliable one
- The scoring system sometimes selected suboptimal results
- There was no UI option to select which preprocessing method to use

### Solutions Implemented
- Added a `preferred_method` property to the `TextOCR` class to specify which preprocessing method to prioritize
- Modified the `extract_text` method to prioritize results from the preferred method
- Added a dropdown menu to the OCR controls to select the preferred method
- Set `thresh3` (Otsu's thresholding) as the default method as it produces the best results
- Updated the `ConfigManager` to store and retrieve the preferred OCR method
- Added detailed logging of OCR results by method for better debugging

### Future Prevention
- Always provide UI options for critical processing parameters
- Implement proper fallback mechanisms when preferred methods fail
- Add detailed logging to help diagnose issues with different processing methods

## 2023-07-12: Mouse Movement and OCR Improvements

### Issues Fixed
- Mouse still not moving to center of screen before taking screenshots
- OCR not extracting coordinates from screenshots
- Coordinates not being displayed in the GUI
- Tesseract OCR path not properly configured

### Root Cause Analysis
- The `pyautogui` library might not be working correctly for mouse movement
- Tesseract OCR might not be properly installed or configured
- The coordinate region might not be capturing the area where coordinates are displayed in the game UI

### Solutions Implemented
- Modified the `_center_mouse_for_measurement` method to use `win32api` for mouse movement instead of `pyautogui`
- Added a fallback to try `pyautogui` if `win32api` fails
- Enhanced the `extract_text` method to check for Tesseract installation and provide better error handling
- Added automatic detection of Tesseract installation path
- Modified the coordinate region to try different areas of the screen (bottom left, bottom center, top right, etc.)
- Added a `try_all_coordinate_regions` method to systematically try different regions of the screen
- Modified the `_update_coordinates` method to try all coordinate regions if the initial update fails

### Future Prevention
- Use multiple mouse movement methods with fallbacks
- Always check for proper installation and configuration of external dependencies
- Try multiple screen regions when extracting information from the UI
- Add comprehensive error handling and logging

## 2023-07-11: Mouse Centering and Coordinate Extraction Fixes

### Issues Fixed
- Mouse not moving to the center of the screen before taking screenshots
- Coordinates not being extracted or displayed in the GUI
- Auto-update not enabled by default in the coordinate display widget

### Root Cause Analysis
- The mouse centering code in `GameWorldCoordinator._center_mouse_for_measurement()` was not properly verifying that the mouse had actually moved
- The delay after centering the mouse was too short, not giving the game UI enough time to update
- The coordinate display widget was not starting with auto-update enabled by default

### Solutions Implemented
- Enhanced the `_center_mouse_for_measurement()` method to verify mouse position after moving
- Added more detailed logging to track mouse movement and coordinate extraction
- Increased the delay after centering the mouse from 0.2 to 0.5 seconds
- Modified the `CoordinateDisplayWidget` to start with auto-update enabled by default
- Added a forced initial update to the coordinate display widget

### Future Prevention
- Always verify the results of mouse movement operations
- Add sufficient delays when interacting with the game UI
- Enable auto-update features by default when they are critical to functionality
- Add more detailed logging for debugging purposes

## 2023-07-11: Fixed GameCoordinates Import Error

### Issues Fixed
- Application failing to start due to `NameError: name 'GameCoordinates' is not defined` in `text_ocr.py`

### Root Cause Analysis
- The `_extract_coordinates` method in `TextOCR` class was updated to return `Optional[GameCoordinates]`, but the `GameCoordinates` class wasn't properly imported from `game_state.py`

### Solutions Implemented
- Added proper import statement: `from scout.game_state import GameState, GameCoordinates`

### Future Prevention
- Always ensure that all type annotations have corresponding imports
- Run a quick test after making changes to ensure the application starts correctly

## 2023-07-11: Coordinate Extraction and Stop Key Functionality

### Issues Fixed
- Coordinates not being consistently extracted and displayed in the GUI
- No way to stop OCR and other processes using keyboard shortcuts
- Inconsistent coordinate display when OCR fails
- Insufficient logging for debugging OCR issues

### Root Cause Analysis
- The OCR system had multiple signal paths that weren't properly connected
- The `_on_coordinates_updated` method in `GameWorldSearchTab` wasn't properly updating the UI
- The `_update_coordinates` method in `CoordinateDisplayWidget` didn't handle OCR failures gracefully
- The `_process_region` and `_extract_coordinates` methods in `TextOCR` weren't properly emitting signals
- No global key event handling for stopping processes

### Solutions Implemented
- Added a `keyPressEvent` method to the `OverlayController` class to handle Escape and Q key presses
- Enhanced the `_on_coordinates_updated` method in `GameWorldSearchTab` to ensure it properly updates the UI
- Improved the `_update_coordinates` method in `CoordinateDisplayWidget` to handle different coordinate sources
- Enhanced the `_process_region` and `_extract_coordinates` methods in `TextOCR` to ensure proper signal emission
- Added more comprehensive logging throughout the OCR process for better debugging
- Improved error handling in coordinate extraction and display
- Added fallback to display last known coordinates when OCR fails

### Future Prevention
- Maintain consistent signal connections between OCR system and UI components
- Ensure all key UI components have proper error handling and fallbacks
- Add comprehensive logging for all critical operations
- Implement global key event handling for common operations like stopping processes

## 2023-07-10: OCR System Integration

### Issues Fixed
- Inconsistent OCR processing paths leading to unreliable coordinate extraction
- Duplicate OCR logic in `GameWorldCoordinator.update_current_position_from_ocr()` and `TextOCR._process_region()`
- Inconsistent debug screenshot naming making it difficult to compare results
- Coordinate display not updating properly in the game world search tab

### Root Cause Analysis
- The OCR system had two separate processing paths:
  1. `TextOCR._process_region()` - Used by the "old" OCR system
  2. `GameWorldCoordinator.update_current_position_from_ocr()` - Used by the game world search system
- These paths used different methods for capturing screenshots, processing images, and extracting coordinates
- Debug screenshots were saved with inconsistent names
- The game world search tab wasn't properly connected to the OCR system's signals

### Solutions Implemented
- Unified OCR processing paths to ensure consistent coordinate extraction
- Modified `GameWorldCoordinator.update_current_position_from_ocr()` to use `TextOCR._process_region()`
- Updated `TextOCR._process_region()` to save debug images with consistent naming
- Connected the `coordinates_updated` signal from `TextOCR` to the `_on_coordinates_updated` method in `GameWorldSearchTab`

### Future Prevention
- Maintain a single source of truth for OCR processing
- Use consistent naming for debug images
- Ensure all UI components are properly connected to the OCR system's signals

## OCR System and Game World Search Integration (2023-07-10)

### Issues Fixed
- Inconsistent OCR processing paths causing coordinate extraction failures
- Missing screenshots during template searches making debugging difficult
- Coordinate display not updating properly in the game world search tab
- Game world coordinator not properly utilizing the TextOCR system

### Root Cause Analysis
The main issue was that there were two separate processing paths for OCR:
1. `TextOCR._process_region()` - Used by the main OCR system
2. `GameWorldCoordinator.update_current_position_from_ocr()` - Used by the game world search system

This dual approach led to inconsistent results, as the game world search system was not properly integrated with the OCR system. Additionally, screenshots were not being consistently saved during template searches, making it difficult to debug coordinate extraction issues.

### Solutions Implemented
1. Modified `GameWorldCoordinator.update_current_position_from_ocr()` to use the TextOCR system directly
2. Enhanced `GameWorldSearch._check_for_templates()` to always save screenshots for debugging
3. Improved `CoordinateDisplayWidget._update_coordinates()` to handle different coordinate sources
4. Added additional logging and debug screenshots for better troubleshooting
5. Ensured the game world search tab properly updates when coordinates change

### Future Prevention
- Maintain a single source of truth for OCR processing
- Use consistent naming for debug images
- Ensure all UI components are properly connected to the OCR system's signals
- Add more comprehensive logging for coordinate updates
- Implement better error handling for OCR failures

## 2023-08-01: Fixed OCR Process and Q/Escape Key Handling

### Issue
1. Coordinates were not being displayed in the GUI despite being extracted by the OCR process
2. The OCR process could not be canceled with Q/Escape keys

### Root Cause
1. The coordinate display widget was only updating the display when the OCR process returned success, but wasn't checking if there were valid coordinates in the game world coordinator
2. The keyPressEvent method was checking `self.text_ocr.active` which wasn't properly tracking the OCR state
3. The TextOCR class had inconsistent state tracking with both `self.active` and internal timer state

### Solution
1. Modified the `_update_coordinates` method in `CoordinateDisplayWidget` to:
   - Get the current position regardless of OCR success
   - Display partial coordinates with placeholders for missing values
   - Use different colors to indicate full, partial, or missing coordinates
2. Fixed the `keyPressEvent` method in `OverlayController` to:
   - Check the OCR button state instead of `text_ocr.active`
   - Add proper error handling when stopping the OCR process
3. Improved the TextOCR class with:
   - Added a proper `active` property to track OCR state
   - Ensured consistent state tracking between the property and internal timer

### Prevention
1. Added more detailed logging to track coordinate display issues
2. Improved error handling throughout the OCR process
3. Added proper state tracking in the TextOCR class
4. Used button state as the source of truth for process state in key event handling

### Testing
1. Verified that coordinates are displayed in the GUI even when some values are missing
2. Confirmed that the Q/Escape keys properly stop the OCR process
3. Tested error handling by simulating OCR failures
4. Verified that the OCR button state correctly reflects the OCR process state

## 2023-08-02: Fixed OCR Process Performance and Temporary Files Issues

### Issues Fixed
- Application getting stuck or becoming unresponsive during OCR operations
- Excessive temporary PNG files being created in the system temp folder
- OCR process not stopping when using Q/Escape keys
- Coordinates not being displayed in the GUI despite being extracted

### Root Cause Analysis
- The pytesseract library was creating numerous temporary files for each OCR operation
- Multiple OCR methods were being run in quick succession, creating a large number of temporary files
- The OCR process was being called too frequently without rate limiting
- The drag calibration system increased the number of OCR operations, exacerbating the issue

### Solutions Implemented
1. Optimized the OCR process in `TextOCR.extract_text()`:
   - Only process the preferred OCR method when not in auto mode
   - Standardized configuration parameters to reduce redundancy
   - Simplified the OCR method selection process
2. Added rate limiting to `GameWorldCoordinator.update_current_position_from_ocr()`:
   - Implemented a minimum 500ms delay between OCR operations
   - Added early return with existing coordinates when rate limited
   - Improved logging to track rate-limited operations
3. Enhanced error handling throughout the OCR process:
   - Better timeout handling to prevent the application from hanging
   - Improved fallback to existing coordinates when OCR fails
   - More robust state tracking for the OCR process

### Prevention Strategies
1. Implemented rate limiting to prevent excessive OCR operations
2. Reduced the number of temporary files created during OCR
3. Improved error handling and timeout mechanisms
4. Enhanced logging to better track OCR operations and failures
5. Added more robust state tracking for the OCR process

### Testing
1. Verified that the application remains responsive during OCR operations
2. Confirmed that fewer temporary files are created during OCR
3. Tested that the Q/Escape keys properly stop the OCR process
4. Verified that coordinates are displayed in the GUI even when some values are missing
5. Confirmed that the OCR process works correctly with the drag calibration system 